{
 "cells": [
  {
   "cell_type": "code",
   "execution_count": 3,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "1994"
      ]
     },
     "execution_count": 3,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "\"13. Roman to Integer\"\n",
    "\"\"\"Roman numerals are represented by seven different symbols: I, V, X, L, C, D and M.\n",
    "\n",
    "Symbol       Value\n",
    "I             1\n",
    "V             5\n",
    "X             10\n",
    "L             50\n",
    "C             100\n",
    "D             500\n",
    "M             1000\n",
    "For example, two is written as II in Roman numeral, just two one's added together. \n",
    "Twelve is written as, XII, which is simply X + II. The number twenty seven is written as XXVII, which is XX + V + II.\n",
    "\n",
    "Roman numerals are usually written largest to smallest from left to right. However, the numeral for four is not IIII. \n",
    "Instead, the number four is written as IV. Because the one is before the five we subtract it making four. \n",
    "The same principle applies to the number nine, which is written as IX. \n",
    "There are six instances where subtraction is used:\n",
    "\n",
    "I can be placed before V (5) and X (10) to make 4 and 9. \n",
    "X can be placed before L (50) and C (100) to make 40 and 90. \n",
    "C can be placed before D (500) and M (1000) to make 400 and 900.\n",
    "Given a roman numeral, convert it to an integer. Input is guaranteed to be within the range from 1 to 3999.\n",
    "\n",
    "Example 1:\n",
    "\n",
    "Input: \"III\"\n",
    "Output: 3\n",
    "Example 2:\n",
    "\n",
    "Input: \"IV\"\n",
    "Output: 4\n",
    "Example 3:\n",
    "\n",
    "Input: \"IX\"\n",
    "Output: 9\n",
    "Example 4:\n",
    "\n",
    "Input: \"LVIII\"\n",
    "Output: 58\n",
    "Explanation: L = 50, V= 5, III = 3.\n",
    "Example 5:\n",
    "\n",
    "Input: \"MCMXCIV\"\n",
    "Output: 1994\n",
    "Explanation: M = 1000, CM = 900, XC = 90 and IV = 4.\"\"\"\n",
    "\"Sample solution，思想很重要\"\n",
    "class Solution(object):\n",
    "    def romanToInt(s):\n",
    "        \"\"\"\n",
    "        :type s: str\n",
    "        :rtype: int\n",
    "        \"\"\"\n",
    "        dic = {'I':1, 'V':5, 'X':10, 'L':50, 'C':100, 'D':500, 'M':1000}\n",
    "        res = 0\n",
    "        for i in range(len(s)):\n",
    "            if i+1<len(s) and dic[s[i+1]]>dic[s[i]]:\n",
    "                res -= dic[s[i]]\n",
    "            else:\n",
    "                res += dic[s[i]]\n",
    "        return res\n",
    "Solution.romanToInt('MCMXCIV')"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 6,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "'fl'"
      ]
     },
     "execution_count": 6,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "\"14. Longest Common Prefix\"\n",
    "\"\"\"Write a function to find the longest common prefix string amongst an array of strings.\n",
    "\n",
    "If there is no common prefix, return an empty string \"\".\n",
    "\n",
    "Example 1:\n",
    "\n",
    "Input: [\"flower\",\"flow\",\"flight\"]\n",
    "Output: \"fl\"\n",
    "Example 2:\n",
    "\n",
    "Input: [\"dog\",\"racecar\",\"car\"]\n",
    "Output: \"\"\n",
    "Explanation: There is no common prefix among the input strings.\"\"\"\n",
    "\n",
    "\"Sample solution,只是前缀，不包括中间\"\n",
    "class Solution(object):\n",
    "    def longestCommonPrefix(strs):\n",
    "        prefix=\"\"\n",
    "        if len(strs)==0: return prefix\n",
    "\n",
    "        for i in range(len(min(strs,key=len))):\n",
    "            c=strs[0][i]\n",
    "            if all(a[i]==c for a in strs):\n",
    "                prefix+=c\n",
    "            else:\n",
    "                break\n",
    "        return prefix\n",
    "Solution.longestCommonPrefix([\"flower\",\"flow\",\"flight\"])"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 21,
   "metadata": {},
   "outputs": [],
   "source": [
    "\"20. Valid Parentheses\"\n",
    "\"\"\"Given a string containing just the characters '(', ')', '{', '}', '[' and ']', \n",
    "determine if the input string is valid.\n",
    "\n",
    "An input string is valid if:\n",
    "\n",
    "Open brackets must be closed by the same type of brackets.\n",
    "Open brackets must be closed in the correct order.\n",
    "Note that an empty string is also considered valid.\n",
    "\n",
    "Example 1:\n",
    "\n",
    "Input: \"()\"\n",
    "Output: true\n",
    "Example 2:\n",
    "\n",
    "Input: \"()[]{}\"\n",
    "Output: true\n",
    "Example 3:\n",
    "\n",
    "Input: \"(]\"\n",
    "Output: false\n",
    "Example 4:\n",
    "\n",
    "Input: \"([)]\"\n",
    "Output: false\n",
    "Example 5:\n",
    "\n",
    "Input: \"{[]}\"\n",
    "Output: true\"\"\"\n",
    "\"Sample solution，思想很重要\"\n",
    "class Solution(object):\n",
    "    def isValid(s):\n",
    "        \"\"\"\n",
    "        :type s: str\n",
    "        :rtype: bool\n",
    "        \"\"\"\n",
    "        dic ={ '(':')', '[':']', '{':'}'}\n",
    "       \n",
    "        stack = []\n",
    "        for c in s:\n",
    "            if c in dic:\n",
    "                stack.append(c)\n",
    "            else:\n",
    "                if stack:\n",
    "                    top = stack.pop()\n",
    "                    if c != dic[top]:\n",
    "                        return False\n",
    "                else:\n",
    "                    return False\n",
    "        return not stack\n",
    "\n",
    "Solution.isValid(\"()[]{}\")"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "\"28. Implement strStr()\"\n",
    "\"\"\"Implement strStr().\n",
    "\n",
    "Return the index of the first occurrence of needle in haystack, or -1 if needle is not part of haystack.\n",
    "\n",
    "Example 1:\n",
    "\n",
    "Input: haystack = \"hello\", needle = \"ll\"\n",
    "Output: 2\n",
    "Example 2:\n",
    "\n",
    "Input: haystack = \"aaaaa\", needle = \"bba\"\n",
    "Output: -1\n",
    "Clarification:\n",
    "\n",
    "What should we return when needle is an empty string? This is a great question to ask during an interview.\n",
    "\n",
    "For the purpose of this problem, we will return 0 when needle is an empty string. \n",
    "This is consistent to C's strstr() and Java's indexOf().\"\"\"\n",
    "\"Sample solution\"\n",
    "class Solution:\n",
    "    def strStr(haystack, needle):\n",
    "        \"\"\"\n",
    "        :type haystack: str\n",
    "        :type needle: str\n",
    "        :rtype: int\n",
    "        \"\"\"\n",
    "        M, N = len(haystack), len(needle)\n",
    "        for i in range(M - N + 1):\n",
    "            if haystack[i : i + N] == needle:\n",
    "                return i\n",
    "        return -1\n",
    "#         return haystack.find(needle)  太简单"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 34,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "'111221'"
      ]
     },
     "execution_count": 34,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "\"38. Count and Say\"\n",
    "\"\"\"The count-and-say sequence is the sequence of integers with the first five terms as following:\n",
    "\n",
    "1.     1\n",
    "2.     11\n",
    "3.     21\n",
    "4.     1211\n",
    "5.     111221\n",
    "1 is read off as \"one 1\" or 11.\n",
    "11 is read off as \"two 1s\" or 21.\n",
    "21 is read off as \"one 2, then one 1\" or 1211.\n",
    "\n",
    "Given an integer n where 1 ≤ n ≤ 30, generate the nth term of the count-and-say sequence. You can do so recursively, \n",
    "in other words from the previous member read off the digits, counting the number of digits in groups of the same digit.\n",
    "\n",
    "Note: Each term of the sequence of integers will be represented as a string.\n",
    "\n",
    " \n",
    "\n",
    "Example 1:\n",
    "\n",
    "Input: 1\n",
    "Output: \"1\"\n",
    "Explanation: This is the base case.\n",
    "Example 2:\n",
    "\n",
    "Input: 4\n",
    "Output: \"1211\"\n",
    "Explanation: For n = 3 the term was \"21\" in which we have two groups \"2\" and \"1\", \"2\" can be read as \"12\" \n",
    "which means frequency = 1 and value = 2, the same way \"1\" is read as \"11\", so the answer is the concatenation \n",
    "of \"12\" and \"11\" which is \"1211\".\"\"\"\n",
    "\n",
    "\"Sample solution, intertools.groupby 得出第一个是数字，第二个是相同的数字list\"\n",
    "class Solution(object):\n",
    "    def countAndSay(n):\n",
    "        \"\"\"\n",
    "        :type n: int\n",
    "        :rtype: str\n",
    "        \"\"\"\n",
    "        res = '1'\n",
    "        for i in range(n-1):\n",
    "            res = ''.join([str(len(list(group))) + digit for digit, group in itertools.groupby(res)])\n",
    "        return res\n",
    "Solution.countAndSay(5)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 36,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "5"
      ]
     },
     "execution_count": 36,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "\"58. Length of Last Word\"\n",
    "\"\"\"Given a string s consists of upper/lower-case alphabets and empty space characters ' ', \n",
    "return the length of last word (last word means the last appearing word if we loop from left to right) in the string.\n",
    "\n",
    "If the last word does not exist, return 0.\n",
    "\n",
    "Note: A word is defined as a maximal substring consisting of non-space characters only.\n",
    "\n",
    "Example:\n",
    "\n",
    "Input: \"Hello World\"\n",
    "Output: 5\"\"\"\n",
    "\"My solution\"\n",
    "class Solution:\n",
    "    def lengthOfLastWord(s):\n",
    "        if not s.split():\n",
    "            return 0\n",
    "        return len(s.split()[-1])\n",
    "Solution.lengthOfLastWord(\"Hello World\")"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 43,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "'0b10101'"
      ]
     },
     "execution_count": 43,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "\"67. Add Binary\"\n",
    "\"\"\"Given two binary strings, return their sum (also a binary string).\n",
    "\n",
    "The input strings are both non-empty and contains only characters 1 or 0.\n",
    "\n",
    "Example 1:\n",
    "\n",
    "Input: a = \"11\", b = \"1\"\n",
    "Output: \"100\"\n",
    "Example 2:\n",
    "\n",
    "Input: a = \"1010\", b = \"1011\"\n",
    "Output: \"10101\"\n",
    " \n",
    "\n",
    "Constraints:\n",
    "\n",
    "Each string consists only of '0' or '1' characters.\n",
    "1 <= a.length, b.length <= 10^4\n",
    "Each string is either \"0\" or doesn't contain any leading zero.\"\"\"\n",
    "\"Sample solution\"\n",
    "class Solution(object):\n",
    "    def addBinary(a, b):\n",
    "        \"\"\"\n",
    "        :type a: str\n",
    "        :type b: str\n",
    "        :rtype: str\n",
    "        \"\"\"\n",
    "        return bin(int(a, 2) + int(b, 2))[2:]\n",
    "Solution.addBinary(\"1010\",\"1011\")"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 59,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "amanaplanacanalpanama\n"
     ]
    },
    {
     "data": {
      "text/plain": [
       "True"
      ]
     },
     "execution_count": 59,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "\"125. Valid Palindrome\"\n",
    "\"\"\"Given a string, determine if it is a palindrome, considering only alphanumeric characters and ignoring cases.\n",
    "\n",
    "Note: For the purpose of this problem, we define empty string as valid palindrome.\n",
    "\n",
    "Example 1:\n",
    "\n",
    "Input: \"A man, a plan, a canal: Panama\"\n",
    "Output: true\n",
    "Example 2:\n",
    "\n",
    "Input: \"race a car\"\n",
    "Output: false\"\"\"\n",
    "import re\n",
    "class Solution(object):\n",
    "    def isPalindrome(s):\n",
    "        \"\"\"\n",
    "        :type s: str\n",
    "        :rtype: bool\n",
    "        \"\"\"\n",
    "        s = s.lower()\n",
    "        s = re.sub(\"[\\W_]\", \"\", s)\n",
    "        print(s)\n",
    "        N = len(s)\n",
    "        left, right = 0, N - 1\n",
    "        while left <= right:\n",
    "            if s[left] != s[right]:\n",
    "                return False\n",
    "            left += 1\n",
    "            right -= 1\n",
    "        return True\n",
    "Solution.isPalindrome(\"A man, a plan, a canal: Panama\")"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 60,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "['--++-+-+++', '+--+-+-+++', '++---+-+++', '++++-+---+', '++++-+-+--']"
      ]
     },
     "execution_count": 60,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "\"293. Flip Game\"\n",
    "\"\"\"You are playing the following Flip Game with your friend: Given a string that contains \n",
    "only these two characters: + and -, you and your friend take turns to flip two consecutive “++” into “–”. \n",
    "The game ends when a person can no longer make a move and therefore the other person will be the winner.\n",
    "\n",
    "Write a function to compute all possible states of the string after one valid move.\n",
    "\n",
    "Example:\n",
    "\n",
    "Input: s = “++++“\n",
    "Output:\n",
    "[\n",
    "”--++”,\n",
    "\"+--+\",\n",
    "\"++--\"\n",
    "]\n",
    "Note: If there is no valid move, return an empty list [].\"\"\"\n",
    "\n",
    "\"Sample Solution\"\n",
    "class Solution:\n",
    "    def generatePossibleNextMoves(s):\n",
    "        \"\"\"\n",
    "        :type s: str\n",
    "        :rtype: List[str]\n",
    "        \"\"\"\n",
    "        return [s[:i-1]+\"--\"+s[i+1:] for i in range(1, len(s)) if s[i-1:i+1]==\"++\"]\n",
    "Solution.generatePossibleNextMoves('++++-+-+++')"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 65,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "['o', 'l', 'l', 'e', 'h']"
      ]
     },
     "execution_count": 65,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "\"344. Reverse String\"\n",
    "\"\"\"Write a function that reverses a string. The input string is given as an array of characters char[].\n",
    "\n",
    "Do not allocate extra space for another array, you must do this by modifying the input array in-place with O(1) \n",
    "extra memory.\n",
    "\n",
    "You may assume all the characters consist of printable ascii characters.\n",
    "\n",
    "Example 1:\n",
    "\n",
    "Input: [\"h\",\"e\",\"l\",\"l\",\"o\"]\n",
    "Output: [\"o\",\"l\",\"l\",\"e\",\"h\"]\n",
    "Example 2:\n",
    "\n",
    "Input: [\"H\",\"a\",\"n\",\"n\",\"a\",\"h\"]\n",
    "Output: [\"h\",\"a\",\"n\",\"n\",\"a\",\"H\"]\"\"\"\n",
    "\"Sample solution, two pointer method，依次首位交换\"\n",
    "class Solution:\n",
    "    def reverseString(s):\n",
    "        left, right = 0, len(s) - 1\n",
    "        while left < right:\n",
    "            s[left], s[right] = s[right], s[left]\n",
    "            left, right = left + 1, right - 1\n",
    "        return s\n",
    "Solution.reverseString([\"h\",\"e\",\"l\",\"l\",\"o\"])"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 73,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "'holle'"
      ]
     },
     "execution_count": 73,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "\"345. Reverse Vowels of a String\"\n",
    "\"\"\"Write a function that takes a string as input and reverse only the vowels of a string.\n",
    "\n",
    "Example 1:\n",
    "\n",
    "Input: \"hello\"\n",
    "Output: \"holle\"\n",
    "Example 2:\n",
    "\n",
    "Input: \"leetcode\"\n",
    "Output: \"leotcede\"\n",
    "Note:\n",
    "The vowels does not include the letter \"y\".\"\"\"\n",
    "\"Sample solution\"\n",
    "class Solution:\n",
    "    def reverseVowels(s):\n",
    "        vowels = [i for i in s if i in 'aeiouAEIOU']\n",
    "        return re.sub('[aeiouAEIOU]', lambda m: vowels.pop(), s)    \n",
    "Solution.reverseVowels(\"hello\")"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 90,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "False"
      ]
     },
     "execution_count": 90,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "\"383. Ransom Note\"\n",
    "\"\"\"Given an arbitrary ransom note string and another string containing letters from all the magazines, \n",
    "write a function that will return true if the ransom note can be constructed from the magazines ; \n",
    "otherwise, it will return false.\n",
    "\n",
    "Each letter in the magazine string can only be used once in your ransom note.\n",
    "\n",
    "Example 1:\n",
    "\n",
    "Input: ransomNote = \"a\", magazine = \"b\"\n",
    "Output: false\n",
    "Example 2:\n",
    "\n",
    "Input: ransomNote = \"aa\", magazine = \"ab\"\n",
    "Output: false\n",
    "Example 3:\n",
    "\n",
    "Input: ransomNote = \"aa\", magazine = \"aab\"\n",
    "Output: true\"\"\"\n",
    "\"My solution\"\n",
    "class Solution:\n",
    "    def canConstruct(ransomNote, magazine):\n",
    "        ransomdic = {i:ransomNote.count(i) for i in set(ransomNote)}\n",
    "        magdic = {i:magazine.count(i) for i in set(magazine)}\n",
    "        return all(i in magdic and ransomdic[i]<=magdic[i] for i in ransomdic)\n",
    "Solution.canConstruct(\"fihjjjjei\",\"hjibagacbhadfaefdjaeaebgi\")"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 96,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "False"
      ]
     },
     "execution_count": 96,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "\"Sample Solution, 差不多\"\n",
    "import collections\n",
    "from collections import Counter\n",
    "class Solution:\n",
    "    def canConstruct(ransomNote, magazine):\n",
    "        \"\"\"\n",
    "        :type ransomNote: str\n",
    "        :type magazine: str\n",
    "        :rtype: bool\n",
    "        \"\"\"\n",
    "        rcount = Counter(ransomNote)\n",
    "        mcount = Counter(magazine)\n",
    "        for r, c in rcount.items():\n",
    "            if c > mcount[r]:\n",
    "                return False\n",
    "        return True\n",
    "Solution.canConstruct(\"fihjjjjei\",\"hjibagacbhadfaefdjaeaebgi\")"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 97,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "-1"
      ]
     },
     "execution_count": 97,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "\"387. First Unique Character in a String, also in Hashtable\"\n",
    "\"\"\"Given a string, find the first non-repeating character in it and return its index. \n",
    "If it doesn't exist, return -1.\n",
    "\n",
    "Examples:\n",
    "\n",
    "s = \"leetcode\"\n",
    "return 0.\n",
    "\n",
    "s = \"loveleetcode\"\n",
    "return 2.\"\"\"\n",
    "\"Sample solution\"\n",
    "class Solution:\n",
    "    def firstUniqChar(s):\n",
    "        \"\"\"\n",
    "        :type s: str\n",
    "        :rtype: int\n",
    "        \"\"\"\n",
    "        # build hash map : character and how often it appears\n",
    "        count = collections.Counter(s)\n",
    "        \n",
    "        # find the index\n",
    "        for idx, ch in enumerate(s):\n",
    "            if count[ch] == 1:\n",
    "                return idx     \n",
    "        return -1   \n",
    "Solution.firstUniqChar('bb')"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 108,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "True"
      ]
     },
     "execution_count": 108,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "\"408. Valid Word Abbreviation\"\n",
    "\"\"\"Given a non-empty string s and an abbreviation abbr, return whether the string matches with the given abbreviation.\n",
    "\n",
    "A string such as \"word\" contains only the following valid abbreviations:\n",
    "\n",
    "[\"word\", \"1ord\", \"w1rd\", \"wo1d\", \"wor1\", \"2rd\", \"w2d\", \"wo2\", \"1o1d\", \"1or1\", \"w1r1\", \"1o2\", \"2r1\", \"3d\", \"w3\", \"4\"]\n",
    "Notice that only the above abbreviations are valid abbreviations of the string \"word\". \n",
    "Any other string is not a valid abbreviation of \"word\".\n",
    "\n",
    "Note:\n",
    "Assume s contains only lowercase letters and abbr contains only lowercase letters and digits.\n",
    "\n",
    "Example 1:\n",
    "\n",
    "Given s = \"internationalization\", abbr = \"i12iz4n\":\n",
    "\n",
    "Return true.\n",
    "Example 2:\n",
    "\n",
    "Given s = \"apple\", abbr = \"a2e\":\n",
    "\n",
    "Return false.\"\"\"\n",
    "\n",
    "\"Sample solution, 没懂\"\n",
    "class Solution(object):\n",
    "    def validWordAbbreviation(word, abbr):\n",
    "        \"\"\"\n",
    "        :type word: str\n",
    "        :type abbr: str\n",
    "        :rtype: bool\n",
    "        \"\"\"\n",
    "        size = len(word)\n",
    "        cnt = loc = 0\n",
    "        for w in abbr:\n",
    "            if w.isdigit():\n",
    "                if w == '0' and cnt == 0:\n",
    "                    return False\n",
    "                cnt = cnt * 10 + int(w)\n",
    "            else:\n",
    "                loc += cnt\n",
    "                cnt = 0\n",
    "                if loc >= size or word[loc] != w:\n",
    "                    return False\n",
    "                loc += 1\n",
    "        return loc + cnt == size\n",
    "Solution.validWordAbbreviation(\"internationalization\", \"i12iz4n\")"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 126,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "'5'"
      ]
     },
     "execution_count": 126,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "\"415. Add Strings\"\n",
    "\"\"\"Given two non-negative integers num1 and num2 represented as string, return the sum of num1 and num2.\n",
    "\n",
    "Note:\n",
    "\n",
    "The length of both num1 and num2 is < 5100.\n",
    "Both num1 and num2 contains only digits 0-9.\n",
    "Both num1 and num2 does not contain any leading zero.\n",
    "You must not use any built-in BigInteger library or convert the inputs to integer directly.\"\"\"\n",
    "\"Sample Solution，有点复杂，https://leetcode.com/problems/add-strings/solution/\"\n",
    "class Solution:\n",
    "    def addStrings(num1, num2):\n",
    "        res = []\n",
    "\n",
    "        carry = 0\n",
    "        p1 = len(num1) - 1\n",
    "        p2 = len(num2) - 1\n",
    "        while p1 >= 0 or p2 >= 0:\n",
    "            x1 = ord(num1[p1]) - ord('0') if p1 >= 0 else 0\n",
    "            x2 = ord(num2[p2]) - ord('0') if p2 >= 0 else 0\n",
    "            value = (x1 + x2 + carry) % 10\n",
    "            carry = (x1 + x2 + carry) // 10\n",
    "            res.append(value)\n",
    "            p1 -= 1\n",
    "            p2 -= 1\n",
    "        \n",
    "        if carry:\n",
    "            res.append(carry)\n",
    "        \n",
    "        return ''.join(str(x) for x in res[::-1])\n",
    "Solution.addStrings('2','3')"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 127,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "5"
      ]
     },
     "metadata": {},
     "output_type": "display_data"
    },
    {
     "data": {
      "text/plain": [
       "5"
      ]
     },
     "execution_count": 127,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "\"434. Number of Segments in a String\"\n",
    "\"\"\"Count the number of segments in a string, where a segment is defined to be a contiguous sequence \n",
    "of non-space characters.\n",
    "\n",
    "Please note that the string does not contain any non-printable characters.\n",
    "\n",
    "Example:\n",
    "\n",
    "Input: \"Hello, my name is John\"\n",
    "Output: 5\"\"\"\n",
    "\"My solution\"\n",
    "class Solution:\n",
    "    def countSegments(s):\n",
    "        return len(s.split())\n",
    "\n",
    "    def countSegments2(s):\n",
    "        segment_count = 0\n",
    "\n",
    "        for i in range(len(s)):\n",
    "            if (i == 0 or s[i-1] == ' ') and s[i] != ' ':\n",
    "                segment_count += 1\n",
    "\n",
    "        return segment_count\n",
    "display(Solution.countSegments(\"Hello, my name is John\"))\n",
    "Solution.countSegments2(\"Hello, my name is John\")"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 173,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "5"
      ]
     },
     "execution_count": 173,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "\"443. String Compression\"\n",
    "\"\"\"Given an array of characters, compress it in-place.\n",
    "\n",
    "The length after compression must always be smaller than or equal to the original array.\n",
    "Every element of the array should be a character (not int) of length 1.\n",
    "After you are done modifying the input array in-place, return the new length of the array.\n",
    " \n",
    "Follow up:\n",
    "Could you solve it using only O(1) extra space?\n",
    "\n",
    "Example 1:\n",
    "Input:\n",
    "[\"a\",\"a\",\"b\",\"b\",\"c\",\"c\",\"c\"]\n",
    "Output:\n",
    "Return 6, and the first 6 characters of the input array should be: [\"a\",\"2\",\"b\",\"2\",\"c\",\"3\"]\n",
    "Explanation:\n",
    "\"aa\" is replaced by \"a2\". \"bb\" is replaced by \"b2\". \"ccc\" is replaced by \"c3\".\n",
    "\n",
    "Example 2:\n",
    "Input:\n",
    "[\"a\"]\n",
    "Output:\n",
    "Return 1, and the first 1 characters of the input array should be: [\"a\"]\n",
    "Explanation:\n",
    "Nothing is replaced.\n",
    "\n",
    "Example 3:\n",
    "Input:\n",
    "[\"a\",\"b\",\"b\",\"b\",\"b\",\"b\",\"b\",\"b\",\"b\",\"b\",\"b\",\"b\",\"b\"]\n",
    "Output:\n",
    "Return 4, and the first 4 characters of the input array should be: [\"a\",\"b\",\"1\",\"2\"].\n",
    "Explanation:\n",
    "Since the character \"a\" does not repeat, it is not compressed. \"bbbbbbbbbbbb\" is replaced by \"b12\".\n",
    "Notice each digit has it's own entry in the array.\"\"\"\n",
    "\"Sample solution, 没懂\"\n",
    "class Solution(object):\n",
    "    def compress(chars):\n",
    "        anchor = write = 0\n",
    "        for read, c in enumerate(chars):\n",
    "            if read + 1 == len(chars) or chars[read + 1] != c:\n",
    "                chars[write] = chars[anchor]\n",
    "                write += 1\n",
    "                if read > anchor:\n",
    "                    for digit in str(read - anchor + 1):\n",
    "                        chars[write] = digit\n",
    "                        write += 1\n",
    "                anchor = read + 1\n",
    "#             print(read, anchor, c, write)\n",
    "        return write\n",
    "Solution.compress([\"a\",\"a\",\"b\",\"b\",\"b\",\"b\",\"b\",\"b\",\"b\",\"b\",\"b\",\"b\",\"b\"])"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 172,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "5"
      ]
     },
     "execution_count": 172,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "\"Sample solution2, 没懂\"\n",
    "class Solution(object):\n",
    "    def compress(chars):\n",
    "        \"\"\"\n",
    "        :type chars: List[str]\n",
    "        :rtype: int\n",
    "        \"\"\"\n",
    "        pre = chars[0]\n",
    "        count = 0\n",
    "        pos = 0\n",
    "        for ch in chars:\n",
    "            if pre == ch:\n",
    "                count += 1\n",
    "            else:\n",
    "                chars[pos] = pre\n",
    "                pos += 1\n",
    "                if count > 1:\n",
    "                    count = str(count)\n",
    "                    for i in range(len(count)):\n",
    "                        chars[pos] = count[i]\n",
    "                        pos += 1\n",
    "                count = 1\n",
    "                pre = ch\n",
    "#             print(pre, pos, count, chars)\n",
    "        chars[pos] = pre\n",
    "        pos += 1\n",
    "        if count > 1:\n",
    "            count = str(count)\n",
    "            for i in range(len(count)):\n",
    "                chars[pos] = count[i]\n",
    "                pos += 1\n",
    "        return pos\n",
    "Solution.compress([\"a\",\"a\",\"b\",\"b\",\"b\",\"b\",\"b\",\"b\",\"b\",\"b\",\"b\",\"b\",\"b\"])"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 184,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "(5, ['a', '2', 'b', '1', '1', 'b', 'b', 'b', 'b', 'b', 'b', 'b'])"
      ]
     },
     "execution_count": 184,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "\"My solution, also works\"\n",
    "def compress(chars):\n",
    "    a = ''\n",
    "    count = 1\n",
    "    for i in range(len(chars)):\n",
    "        if i+1 == len(chars) or chars[i+1] != chars[i]:\n",
    "            if count ==1:\n",
    "                a = a + chars[i]\n",
    "            else:\n",
    "                a = a + chars[i] + str(count)\n",
    "            count =1\n",
    "        elif chars[i+1] == chars[i]:\n",
    "            count += 1\n",
    "    chars[:len(a)+1] = list(a)\n",
    "    return len(a),chars\n",
    "compress([\"a\",\"a\",\"b\",\"b\",\"b\",\"b\",\"b\",\"b\",\"b\",\"b\",\"b\",\"b\",\"b\"])"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 175,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "True"
      ]
     },
     "execution_count": 175,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "\"459. Repeated Substring Pattern\"\n",
    "\"\"\"Given a non-empty string check if it can be constructed by taking a substring of it \n",
    "and appending multiple copies of the substring together. You may assume the given string \n",
    "consists of lowercase English letters only and its length will not exceed 10000.\n",
    "\n",
    "Example 1:\n",
    "\n",
    "Input: \"abab\"\n",
    "Output: True\n",
    "Explanation: It's the substring \"ab\" twice.\n",
    "Example 2:\n",
    "\n",
    "Input: \"aba\"\n",
    "Output: False\n",
    "Example 3:\n",
    "\n",
    "Input: \"abcabcabcabc\"\n",
    "Output: True\n",
    "Explanation: It's the substring \"abc\" four times. (And the substring \"abcabc\" twice.)\"\"\"\n",
    "\"Sample Solution,整除\"\n",
    "class Solution:\n",
    "    def repeatedSubstringPattern(s):\n",
    "        \"\"\"\n",
    "        :type s: str\n",
    "        :rtype: bool\n",
    "        \"\"\"\n",
    "        len_s = len(s)\n",
    "        for i in range(1, len_s // 2 + 1):\n",
    "            if len_s % i == 0:\n",
    "                sub_s = s[:i]\n",
    "                if sub_s * (len_s // i) == s:\n",
    "                    return True\n",
    "        return False\n",
    "Solution.repeatedSubstringPattern('aaabbbaaabbb')"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "\"520. Detect Capital\"\n",
    "\"\"\"Given a word, you need to judge whether the usage of capitals in it is right or not.\n",
    "\n",
    "We define the usage of capitals in a word to be right when one of the following cases holds:\n",
    "\n",
    "All letters in this word are capitals, like \"USA\".\n",
    "All letters in this word are not capitals, like \"leetcode\".\n",
    "Only the first letter in this word is capital, like \"Google\".\n",
    "Otherwise, we define that this word doesn't use capitals in a right way.\n",
    " \n",
    "\n",
    "Example 1:\n",
    "\n",
    "Input: \"USA\"\n",
    "Output: True\n",
    " \n",
    "\n",
    "Example 2:\n",
    "\n",
    "Input: \"FlaG\"\n",
    "Output: False\"\"\"\n",
    "\"Sample Solution\"\n",
    "import re\n",
    "class Solution:\n",
    "    def detectCapitalUse(word):\n",
    "        return re.fullmatch(r\"[A-Z]*|.[a-z]*\", word)\n",
    "Solutionl.detectCapitalUse(\"FlaG\")"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 178,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "False"
      ]
     },
     "execution_count": 178,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "\"My solution, slow, but fine\"\n",
    "def detectCapitalUse(word):\n",
    "    if len(word)==1:\n",
    "        return True\n",
    "    elif all(i.isupper() for i in word) or all(i.islower() for i in word):\n",
    "        return True\n",
    "    elif word[0].isupper() and all(i.islower() for i in word[1:]):\n",
    "        return True\n",
    "    else:\n",
    "        return False\n",
    "detectCapitalUse(\"FlaG\")"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "\"521. Longest Uncommon Subsequence I\"\n",
    "\"\"\"Given two strings, you need to find the longest uncommon subsequence of this two strings. \n",
    "The longest uncommon subsequence is defined as the longest subsequence of one of these strings \n",
    "and this subsequence should not be any subsequence of the other string.\n",
    "\n",
    "A subsequence is a sequence that can be derived from one sequence by deleting some characters \n",
    "without changing the order of the remaining elements. Trivially, any string is a subsequence of \n",
    "itself and an empty string is a subsequence of any string.\n",
    "\n",
    "The input will be two strings, and the output needs to be the length of the longest uncommon subsequence. \n",
    "If the longest uncommon subsequence doesn't exist, return -1.\n",
    "\n",
    "Example 1:\n",
    "\n",
    "Input: a = \"aba\", b = \"cdc\"\n",
    "Output: 3\n",
    "Explanation: The longest uncommon subsequence is \"aba\", \n",
    "because \"aba\" is a subsequence of \"aba\", \n",
    "but not a subsequence of the other string \"cdc\".\n",
    "Note that \"cdc\" can be also a longest uncommon subsequence.\n",
    "Example 2:\n",
    "\n",
    "Input: a = \"aaa\", b = \"bbb\"\n",
    "Output: 3\n",
    "Example 3:\n",
    "\n",
    "Input: a = \"aaa\", b = \"aaa\"\n",
    "Output: -1\"\"\"\n",
    "\"Sample Solution, 无聊\"\n",
    "class Solution:\n",
    "    def findLUSlength(a,b):\n",
    "        if a==b:\n",
    "            return -1\n",
    "        if a!=b:\n",
    "            return max(len(a),len(b))"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 187,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "'bacdfeg'"
      ]
     },
     "execution_count": 187,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "\"541. Reverse String II\"\n",
    "\"\"\"Given a string and an integer k, you need to reverse the first k characters for every 2k characters \n",
    "counting from the start of the string. If there are less than k characters left, reverse all of them. \n",
    "If there are less than 2k but greater than or equal to k characters, then reverse the first k characters \n",
    "and left the other as original.\n",
    "Example:\n",
    "\n",
    "Input: s = \"abcdefg\", k = 2\n",
    "Output: \"bacdfeg\"\"\"\n",
    "\"Sample solution,奇怪的题目，每2k的k个字母reverse\"\n",
    "class Solution(object):\n",
    "    def reverseStr(s, k):\n",
    "        a = list(s)\n",
    "        for i in range(0, len(a), 2*k):\n",
    "            a[i:i+k] = reversed(a[i:i+k])\n",
    "        return \"\".join(a)\n",
    "Solution.reverseStr(\"abcdefg\", 2)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 188,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "False"
      ]
     },
     "execution_count": 188,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "\"551. Student Attendance Record I\"\n",
    "\"\"\"You are given a string representing an attendance record for a student. \n",
    "The record only contains the following three characters:\n",
    "'A' : Absent.\n",
    "'L' : Late.\n",
    "'P' : Present.\n",
    "A student could be rewarded if his attendance record doesn't contain more than one 'A' (absent) \n",
    "or more than two continuous 'L' (late).\n",
    "\n",
    "You need to return whether the student could be rewarded according to his attendance record.\n",
    "\n",
    "Example 1:\n",
    "\n",
    "Input: \"PPALLP\"\n",
    "Output: True\n",
    "Example 2:\n",
    "\n",
    "Input: \"PPALLL\"\n",
    "Output: False\"\"\"\n",
    "\"My solution\"\n",
    "class Solution:\n",
    "    def checkRecord(s):\n",
    "        return ('LLL' not in s) and (list(s).count('A')<=1)\n",
    "Solution.checkRecord(\"PPALLL\")"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 198,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "\"s'teL ekat edoCteeL tsetnoc\""
      ]
     },
     "execution_count": 198,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "\"557. Reverse Words in a String III\"\n",
    "\"\"\"Given a string, you need to reverse the order of characters in each word within a sentence \n",
    "while still preserving whitespace and initial word order.\n",
    "\n",
    "Example 1:\n",
    "\n",
    "Input: \"Let's take LeetCode contest\"\n",
    "Output: \"s'teL ekat edoCteeL tsetnoc\"\n",
    "Note: In the string, each word is separated by single space and there will not be any extra space in the string.\"\"\"\n",
    "\"My solution\"\n",
    "class Solution:\n",
    "    def reverseWords(s):\n",
    "        split = s.split()\n",
    "        a = []\n",
    "        for i in split:\n",
    "            a.append(i[::-1])\n",
    "        return ' '.join(a)\n",
    "#         return \" \".join([i[::-1] for i in s.split()])   更简便\n",
    "Solution.reverseWords(\"Let's take LeetCode contest\")"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 199,
   "metadata": {},
   "outputs": [],
   "source": [
    "\"606. Construct String from Binary Tree\"\n",
    "\"\"\"You need to construct a string consists of parenthesis and integers from a binary tree with \n",
    "the preorder traversing way.\n",
    "\n",
    "The null node needs to be represented by empty parenthesis pair \"()\". And you need to omit all \n",
    "the empty parenthesis pairs that don't affect the one-to-one mapping relationship between the string \n",
    "and the original binary tree.\n",
    "\n",
    "Example 1:\n",
    "\n",
    "Input: Binary tree: [1,2,3,4]\n",
    "       1\n",
    "     /   \\\n",
    "    2     3\n",
    "   /    \n",
    "  4     \n",
    "\n",
    "Output: \"1(2(4))(3)\"\n",
    "\n",
    "Explanation: Originallay it needs to be \"1(2(4)())(3()())\", \n",
    "but you need to omit all the unnecessary empty parenthesis pairs. \n",
    "And it will be \"1(2(4))(3)\".\n",
    "Example 2:\n",
    "\n",
    "Input: Binary tree: [1,2,3,null,4]\n",
    "       1\n",
    "     /   \\\n",
    "    2     3\n",
    "     \\  \n",
    "      4 \n",
    "\n",
    "Output: \"1(2()(4))(3)\"\n",
    "\n",
    "Explanation: Almost the same as the first example, \n",
    "except we can't omit the first parenthesis pair to break the one-to-one mapping relationship between \n",
    "the input and the output.\"\"\"\n",
    "# Definition for a binary tree node.\n",
    "# class TreeNode(object):\n",
    "#     def __init__(self, x):\n",
    "#         self.val = x\n",
    "#         self.left = None\n",
    "#         self.right = None\n",
    "\"Sample Solution, 不懂\"\n",
    "class Solution(object):\n",
    "    def tree2str(self, t):\n",
    "        \"\"\"\n",
    "        :type t: TreeNode\n",
    "        :rtype: str\n",
    "        \"\"\"\n",
    "        if not t : return ''\n",
    "        subleft = '({})'.format(self.tree2str(t.left)) if t.left or t.right else ''\n",
    "        subright = '({})'.format(self.tree2str(t.right)) if t.right else ''\n",
    "        return '{}{}{}'.format(t.val, subleft, subright)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 214,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "True"
      ]
     },
     "metadata": {},
     "output_type": "display_data"
    },
    {
     "data": {
      "text/plain": [
       "False"
      ]
     },
     "execution_count": 214,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "\"657. Robot Return to Origin\"\n",
    "\"\"\"There is a robot starting at position (0, 0), the origin, on a 2D plane. Given a sequence of its moves, \n",
    "judge if this robot ends up at (0, 0) after it completes its moves.\n",
    "\n",
    "The move sequence is represented by a string, and the character moves[i] represents its ith move. \n",
    "Valid moves are R (right), L (left), U (up), and D (down). If the robot returns to the origin \n",
    "after it finishes all of its moves, return true. Otherwise, return false.\n",
    "\n",
    "Note: The way that the robot is \"facing\" is irrelevant. \"R\" will always make the robot move to the right once, \n",
    "\"L\" will always make it move left, etc. Also, assume that the magnitude of the robot's movement is the same for \n",
    "each move.\n",
    "\n",
    "Example 1:\n",
    "\n",
    "Input: \"UD\"\n",
    "Output: true \n",
    "Explanation: The robot moves up once, and then down once. All moves have the same magnitude, so it ended up \n",
    "at the origin where it started. Therefore, we return true.\n",
    " \n",
    "\n",
    "Example 2:\n",
    "\n",
    "Input: \"LL\"\n",
    "Output: false\n",
    "Explanation: The robot moves left twice. It ends up two \"moves\" to the left of the origin. We return false \n",
    "because it is not at the origin at the end of its moves.\"\"\"\n",
    "\"Sample solution\"\n",
    "class Solution:\n",
    "    def judgeCircle(moves):\n",
    "        return (moves.count('R') == moves.count('L'))  & (moves.count('U') == moves.count('D'))\n",
    "\n",
    "class Solution(object):\n",
    "    def judgeCircle(moves):\n",
    "        x = y = 0\n",
    "        for move in moves:\n",
    "            if move == 'U': y -= 1\n",
    "            elif move == 'D': y += 1\n",
    "            elif move == 'L': x -= 1\n",
    "            elif move == 'R': x += 1\n",
    "\n",
    "        return x == y == 0\n",
    "display(Solution.judgeCircle(\"UDUD\"))\n",
    "        \n",
    "\"My solution, slow\"\n",
    "class Solution:\n",
    "    def judgeCircle(moves):\n",
    "        dic = {'D':(0,-1), 'U':(0,1), 'L':(-1,0), 'R':(1,0)}\n",
    "        x = sum([dic[i][0] for i in moves]), sum([dic[i][1] for i in moves])\n",
    "        return x==(0,0)\n",
    "Solution.judgeCircle(\"LL\")"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 229,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "True"
      ]
     },
     "metadata": {},
     "output_type": "display_data"
    },
    {
     "data": {
      "text/plain": [
       "True"
      ]
     },
     "execution_count": 229,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "\"680. Valid Palindrome II\"\n",
    "\"\"\"Given a non-empty string s, you may delete at most one character. Judge whether you can make it a palindrome.\n",
    "\n",
    "Example 1:\n",
    "\n",
    "Input: \"aba\"\n",
    "Output: True\n",
    "Example 2:\n",
    "\n",
    "Input: \"abca\"\n",
    "Output: True\n",
    "Explanation: You could delete the character 'c'.\"\"\"\n",
    "\"Sample solution\"\n",
    "class Solution(object):\n",
    "    def validPalindrome(s):\n",
    "        \"\"\"\n",
    "        :type s: str\n",
    "        :rtype: bool\n",
    "        \"\"\"\n",
    "        isPalindrome = lambda x : x == x[::-1]\n",
    "        left, right = 0, len(s) - 1\n",
    "        while left <= right:\n",
    "            if s[left] == s[right]:\n",
    "                left += 1\n",
    "                right -= 1\n",
    "            else:\n",
    "                return isPalindrome(s[left + 1 : right + 1]) or isPalindrome(s[left: right])\n",
    "        return True\n",
    "display(Solution.validPalindrome('abaccba'))\n",
    "\n",
    "class Solution(object):\n",
    "    def validPalindrome(s):\n",
    "        def is_pali_range(i, j):\n",
    "            return all(s[k] == s[j-k+i] for k in range(i, j))\n",
    "\n",
    "        for i in range(len(s) // 2):\n",
    "            if s[i] != s[~i]:\n",
    "                j = len(s) - 1 - i\n",
    "                return is_pali_range(i+1, j) or is_pali_range(i, j-1)\n",
    "        return True\n",
    "Solution.validPalindrome('abaccba')"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 224,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "True"
      ]
     },
     "execution_count": 224,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "\"My solution, exceed time limit\"\n",
    "def validPalindrome(s):\n",
    "    for i in range(len(s)):\n",
    "        smimus = s[:i]+s[i+1:]\n",
    "        if smimus == smimus[::-1]:\n",
    "            return True\n",
    "    return s == s[::-1]\n",
    "validPalindrome(\"abca\")"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 234,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "3"
      ]
     },
     "execution_count": 234,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "\"686. Repeated String Match\"\n",
    "\"\"\"Given two strings A and B, find the minimum number of times A has to be repeated such that \n",
    "B is a substring of it. If no such solution, return -1.\n",
    "\n",
    "For example, with A = \"abcd\" and B = \"cdabcdab\".\n",
    "\n",
    "Return 3, because by repeating A three times (“abcdabcdabcd”), B is a substring of it; \n",
    "and B is not a substring of A repeated two times (\"abcdabcd\").\n",
    "\n",
    "Note:\n",
    "The length of A and B will be between 1 and 10000.\"\"\"\n",
    "\"Sample solution\"\n",
    "class Solution(object):\n",
    "    def repeatedStringMatch(A, B):\n",
    "        q = (len(B) - 1) // len(A) + 1\n",
    "        for i in range(2):\n",
    "            if B in A * (q+i): return q+i\n",
    "        return -1\n",
    "Solution.repeatedStringMatch(\"abcd\",\"cdabcdab\")"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 232,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "3"
      ]
     },
     "execution_count": 232,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "\"My solution, exceed time limit\"\n",
    "def repeatedStringMatch(A,B):\n",
    "    for i in range(1,100):\n",
    "        if B in A*i:\n",
    "            return i\n",
    "    return -1\n",
    "\n",
    "repeatedStringMatch(\"abcd\",\"cdabcdab\")"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 6,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "1 0 0 2 0\n",
      "2 0 0 3 0\n",
      "3 1 3 1 0\n",
      "4 1 3 2 0\n",
      "5 1 3 3 0\n",
      "6 0 3 1 3\n",
      "7 0 3 2 3\n",
      "8 1 2 1 5\n",
      "9 1 2 2 5\n"
     ]
    },
    {
     "data": {
      "text/plain": [
       "7"
      ]
     },
     "execution_count": 6,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "\"696. Count Binary Substrings\"\n",
    "\"\"\"Give a string s, count the number of non-empty (contiguous) substrings that have \n",
    "the same number of 0's and 1's, and all the 0's and all the 1's in these substrings are grouped consecutively.\n",
    "\n",
    "Substrings that occur multiple times are counted the number of times they occur.\n",
    "\n",
    "Example 1:\n",
    "\n",
    "Input: \"00110011\"\n",
    "Output: 6\n",
    "Explanation: There are 6 substrings that have equal number of consecutive 1's and 0's: \n",
    "\"0011\", \"01\", \"1100\", \"10\", \"0011\", and \"01\".\n",
    "\n",
    "Notice that some of these substrings repeat and are counted the number of times they occur.\n",
    "\n",
    "Also, \"00110011\" is not a valid substring because all the 0's (and 1's) are not grouped together.\n",
    "Example 2:\n",
    "\n",
    "Input: \"10101\"\n",
    "Output: 4\n",
    "Explanation: There are 4 substrings: \"10\", \"01\", \"10\", \"01\" that have equal number of consecutive 1's and 0's.\"\"\"\n",
    "\"Sample solution, 没太懂\"\n",
    "\"\"\"pre用来记录和当前字符不同的字符的个数\n",
    "cur用来记录当前字符的个数\n",
    "遍历字符串，当第i个字符和第i-1个字符一样时，cur++\n",
    "反之，是0和1的交界处，计算pre和cur中更小的值，为有效子串的个数，有多长就有多少个，再将cur赋值给pre\n",
    "\"\"\"\n",
    "class Solution(object):\n",
    "    def countBinarySubstrings(s):\n",
    "        \"\"\"\n",
    "        :type s: str\n",
    "        :rtype: int\n",
    "        \"\"\"\n",
    "        pre, cur, res = 0, 1, 0\n",
    "      \n",
    "        for i in range(1,len(s)):\n",
    "            if s[i] == s[i-1]:\n",
    "                cur += 1\n",
    "            else:\n",
    "                res += min(pre, cur)\n",
    "                pre, cur = cur, 1\n",
    "            print(i, s[i], pre, cur, res)\n",
    "         \n",
    "        return res + min(pre,cur)\n",
    "Solution.countBinarySubstrings(\"0001110011\")"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 8,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "'hello'"
      ]
     },
     "execution_count": 8,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "\"709. To Lower Case\"\n",
    "\"\"\"Implement function ToLowerCase() that has a string parameter str, and returns the same string in lowercase.\n",
    "\n",
    "Example 1:\n",
    "\n",
    "Input: \"Hello\"\n",
    "Output: \"hello\"\n",
    "Example 2:\n",
    "\n",
    "Input: \"here\"\n",
    "Output: \"here\"\n",
    "Example 3:\n",
    "\n",
    "Input: \"LOVELY\"\n",
    "Output: \"lovely\"\"\"\n",
    "\"Sample solution, ASCII(lowercase)=ASCII(uppercase)+32\"\n",
    "class Solution:\n",
    "    def toLowerCase(S):\n",
    "        lowerString = \"\"\n",
    "        for char in S:\n",
    "            if 65 <= ord(char) <= 90: # check if capital letter\n",
    "                lowerString += chr(ord(char) + 32) # if so convert to small\n",
    "            else:Solution.isPowerOfTwo(8)\n",
    "                lowerString += char # if already lower case, concatenate\n",
    "        return lowerString\n",
    "Solution.toLowerCase(\"Hello\")"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 17,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "['a', 'a', 'b', 'c', 'd', ''] [] [0, 0, 1, 1, 1, 0, 0]\n"
     ]
    },
    {
     "data": {
      "text/plain": [
       "'a<b>abc</b>d'"
      ]
     },
     "execution_count": 17,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "\"758. Bold Words in String\"\n",
    "\"\"\"Given a set of keywords words and a string S, make all appearances of all keywords in S bold. \n",
    "Any letters between <b> and </b> tags become bold.\n",
    "\n",
    "The returned string should use the least number of tags possible, and of course the tags should \n",
    "form a valid combination.\n",
    "\n",
    "For example, given that words = [\"ab\", \"bc\"] and S = \"aabcd\", we should return \"a<b>abc</b>d\". \n",
    "Note that returning \"a<b>a<b>b</b>c</b>d\" would use more tags, so it is incorrect.\n",
    "\n",
    "Note:\n",
    "\n",
    "words has length in range [0, 50].\n",
    "words[i] has length in range [1, 10].\n",
    "S has length in range [0, 500].\n",
    "All characters in words[i] and S are lowercase letters.\"\"\"\n",
    "\"Sample solution\"\n",
    "class Solution(object):\n",
    "    def boldWords(words, S):\n",
    "        \"\"\"\n",
    "        :type words: List[str]\n",
    "        :type S: str\n",
    "        :rtype: str\n",
    "        \"\"\"\n",
    "        N = len(S)\n",
    "        bold = [0] * (N + 2)\n",
    "        for word in words:\n",
    "            start = 0\n",
    "            while True:\n",
    "                idx = S[start:].find(word)\n",
    "                if idx < 0: break\n",
    "                for x in range(start + idx, start + idx + len(word)):\n",
    "                    bold[x + 1] = 1\n",
    "                start += idx + 1\n",
    "        S = list(S) + ['']\n",
    "        ans = []\n",
    "        print(S,ans,bold)\n",
    "        \n",
    "        for x in range(1, N + 1):\n",
    "            if bold[x] == 1 and bold[x - 1] == 0:\n",
    "                ans.append('<b>')\n",
    "            ans.append(S[x - 1])\n",
    "            if bold[x] == 1 and bold[x + 1] == 0:\n",
    "                ans.append('</b>')\n",
    "        return ''.join(ans)\n",
    "Solution.boldWords([\"ab\", \"bc\"],'aabcd')"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 19,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "5"
      ]
     },
     "execution_count": 19,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "\"788. Rotated Digits\"\n",
    "\"\"\"X is a good number if after rotating each digit individually by 180 degrees, \n",
    "we get a valid number that is different from X.  Each digit must be rotated - we cannot choose to leave it alone.\n",
    "\n",
    "A number is valid if each digit remains a digit after rotation. 0, 1, and 8 rotate to themselves; \n",
    "2 and 5 rotate to each other (on this case they are rotated in a different direction, \n",
    "in other words 2 or 5 gets mirrored); 6 and 9 rotate to each other, and the rest of the numbers do not \n",
    "rotate to any other number and become invalid.\n",
    "\n",
    "Now given a positive number N, how many numbers X from 1 to N are good?\n",
    "\n",
    "Example:\n",
    "Input: 10\n",
    "Output: 4\n",
    "Explanation: \n",
    "There are four good numbers in the range [1, 10] : 2, 5, 6, 9.\n",
    "Note that 1 and 10 are not good numbers, since they remain unchanged after rotating.\"\"\"\n",
    "\"Sample solution\"\n",
    "class Solution:\n",
    "    def rotatedDigits(N):\n",
    "        res = 0\n",
    "        for num in range(1, N + 1):\n",
    "            if any(x in str(num) for x in [\"3\", \"4\", \"7\"]):   #不能rotate，去除；any相当于|or，用于list dictionary\n",
    "                continue\n",
    "            if any(x in str(num) for x in [\"2\", \"5\", \"6\", \"9\"]):\n",
    "                res += 1\n",
    "        return res      \n",
    "Solution.rotatedDigits(14)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 22,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "'#11ee66'"
      ]
     },
     "execution_count": 22,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "\"800. Similar RGB Color\"\n",
    "\"\"\"In the following, every capital letter represents some hexadecimal digit from 0 to f.\n",
    "\n",
    "The red-green-blue color “#AABBCC” can be written as “#ABC” in shorthand. \n",
    "For example, “#15c” is shorthand for the color “#1155cc”.\n",
    "\n",
    "Now, say the similarity between two colors “#ABCDEF” and “#UVWXYZ” is -(AB - UV)^2 - (CD - WX)^2 - (EF - YZ)^2.\n",
    "\n",
    "Given the color “#ABCDEF”, return a 7 character color that is most similar to #ABCDEF, \n",
    "and has a shorthand (that is, it can be represented as some “#XYZ”\n",
    "\n",
    "Example 1:\n",
    "Input: color = “#09f166”\n",
    "Output: “#11ee66”\n",
    "Explanation:\n",
    "The similarity is -(0x09 - 0x11)^2 -(0xf1 - 0xee)^2 - (0x66 - 0x66)^2 = -64 -9 -0 = -73.\n",
    "This is the highest among any shorthand color.\n",
    "Note:\n",
    "\n",
    "color is a string of length 7.\n",
    "color is a valid RGB color: for i > 0, color[i] is a hexadecimal digit from 0 to f\n",
    "Any answer which has the same (highest) similarity as the best answer will be accepted.\n",
    "All inputs and outputs should use lowercase letters, and the output is 7 characters.\"\"\"\n",
    "class Solution(object):\n",
    "    def similarRGB(color):\n",
    "        \"\"\"\n",
    "        :type color: str\n",
    "        :rtype: str\n",
    "        \"\"\"\n",
    "        def getClosest(s):    #与s之间距离最小的m\n",
    "            m = ['00','11','22','33','44','55','66','77','88','99','aa','bb','cc','dd','ee','ff']\n",
    "            return min(m, key = lambda x: abs(int(x, 16)- int(s,16)))\n",
    "        \n",
    "        res = ''\n",
    "        color = color[1:]\n",
    "        for i in range(3):\n",
    "            s = color[2*i:2*i+2]\n",
    "            res += getClosest(s)\n",
    "        return '#' +res\n",
    "Solution.similarRGB(\"#09f166\")"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 26,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "2"
      ]
     },
     "execution_count": 26,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "\"804. Unique Morse Code Words\"\n",
    "\"\"\"International Morse Code defines a standard encoding where each letter is mapped to \n",
    "a series of dots and dashes, as follows: \"a\" maps to \".-\", \"b\" maps to \"-...\", \"c\" maps to \"-.-.\", and so on.\n",
    "\n",
    "For convenience, the full table for the 26 letters of the English alphabet is given below:\n",
    "\n",
    "[\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\n",
    "\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"]\n",
    "Now, given a list of words, each word can be written as a concatenation of the Morse code of each letter. \n",
    "For example, \"cab\" can be written as \"-.-..--...\", (which is the concatenation \"-.-.\" + \".-\" + \"-...\"). \n",
    "We'll call such a concatenation, the transformation of a word.\n",
    "\n",
    "Return the number of different transformations among all words we have.\n",
    "\n",
    "Example:\n",
    "Input: words = [\"gin\", \"zen\", \"gig\", \"msg\"]\n",
    "Output: 2\n",
    "Explanation: \n",
    "The transformation of each word is:\n",
    "\"gin\" -> \"--...-.\"\n",
    "\"zen\" -> \"--...-.\"\n",
    "\"gig\" -> \"--...--.\"\n",
    "\"msg\" -> \"--...--.\"\n",
    "\n",
    "There are 2 different transformations, \"--...-.\" and \"--...--.\".\n",
    "Note:\n",
    "\n",
    "The length of words will be at most 100.\n",
    "Each words[i] will have length in range [1, 12].\n",
    "words[i] will only consist of lowercase letters.\"\"\"\n",
    "\"Sample solution, 注意思想ord\"\n",
    "class Solution(object):\n",
    "    def uniqueMorseRepresentations(words):\n",
    "        MORSE = [\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\n",
    "                 \"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\n",
    "                 \"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\n",
    "                 \"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"]\n",
    "\n",
    "        seen = {\"\".join(MORSE[ord(c) - ord('a')] for c in word)   #用ord来数MORSE位置\n",
    "                for word in words}\n",
    "\n",
    "        return len(seen)\n",
    "Solution.uniqueMorseRepresentations([\"gin\", \"zen\", \"gig\", \"msg\"])"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 56,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "'ball'"
      ]
     },
     "execution_count": 56,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "\"819. Most Common Word\"\n",
    "\"\"\"Given a paragraph and a list of banned words, return the most frequent word \n",
    "that is not in the list of banned words.  It is guaranteed there is at least one word \n",
    "that isn't banned, and that the answer is unique.\n",
    "\n",
    "Words in the list of banned words are given in lowercase, and free of punctuation.  \n",
    "Words in the paragraph are not case sensitive.  The answer is in lowercase.\n",
    "\n",
    "Example:\n",
    "\n",
    "Input: \n",
    "paragraph = \"Bob hit a ball, the hit BALL flew far after it was hit.\"\n",
    "banned = [\"hit\"]\n",
    "Output: \"ball\"\n",
    "Explanation: \n",
    "\"hit\" occurs 3 times, but it is a banned word.\n",
    "\"ball\" occurs twice (and no other word does), so it is the most frequent non-banned word in the paragraph. \n",
    "Note that words in the paragraph are not case sensitive,\n",
    "that punctuation is ignored (even if adjacent to words, such as \"ball,\"), \n",
    "and that \"hit\" isn't the answer even though it occurs more because it is banned.\"\"\"\n",
    "\"My solution\"\n",
    "class Solution:\n",
    "    def mostCommonWord(paragraph, banned):\n",
    "        import re\n",
    "        low = re.findall(r'\\w+',paragraph.lower())\n",
    "        res = [i for i in low if i not in banned]\n",
    "        return max(res,key = lambda x: res.count(x))\n",
    "Solution.mostCommonWord(\"Bob hit a ball, the hit BALL flew far after it was hit.\", ['hit'])"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 66,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "'heTmaa uickqmaaa rownbmaaaa oxfmaaaaa umpedjmaaaaaa overmaaaaaaa hetmaaaaaaaa azylmaaaaaaaaa ogdmaaaaaaaaaa'"
      ]
     },
     "execution_count": 66,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "\"824. Goat Latin\"\n",
    "\"\"\"A sentence S is given, composed of words separated by spaces. Each word consists of lowercase and \n",
    "uppercase letters only.\n",
    "\n",
    "We would like to convert the sentence to \"Goat Latin\" (a made-up language similar to Pig Latin.)\n",
    "\n",
    "The rules of Goat Latin are as follows:\n",
    "\n",
    "If a word begins with a vowel (a, e, i, o, or u), append \"ma\" to the end of the word.\n",
    "For example, the word 'apple' becomes 'applema'.\n",
    " \n",
    "If a word begins with a consonant (i.e. not a vowel), remove the first letter and append it to the end, then add \"ma\".\n",
    "For example, the word \"goat\" becomes \"oatgma\".\n",
    " \n",
    "Add one letter 'a' to the end of each word per its word index in the sentence, starting with 1.\n",
    "For example, the first word gets \"a\" added to the end, the second word gets \"aa\" added to the end and so on.\n",
    "Return the final sentence representing the conversion from S to Goat Latin. \n",
    "\n",
    "Example 1:\n",
    "\n",
    "Input: \"I speak Goat Latin\"\n",
    "Output: \"Imaa peaksmaaa oatGmaaaa atinLmaaaaa\"\n",
    "Example 2:\n",
    "\n",
    "Input: \"The quick brown fox jumped over the lazy dog\"\n",
    "Output: \"heTmaa uickqmaaa rownbmaaaa oxfmaaaaa umpedjmaaaaaa overmaaaaaaa hetmaaaaaaaa azylmaaaaaaaaa ogdmaaaaaaaaaa\"\"\"\n",
    "\"Sample solution\"\n",
    "class Solution:\n",
    "    def toGoatLatin(S):\n",
    "        def proc(idx, word):\n",
    "            if word[0] not in 'aeiouAEIOU':\n",
    "                word = word[1:] + word[0]\n",
    "\n",
    "            return word + 'ma' + ('a' * idx)\n",
    "\n",
    "        return ' '.join([proc(i, w) for i, w in enumerate(S.split(), 1)])    #enumerate(,1) 从1开始数\n",
    "Solution.toGoatLatin(\"The quick brown fox jumped over the lazy dog\")"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 63,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "'heTmaa uickqmaaa rownbmaaaa oxfmaaaaa umpedjmaaaaaa overmaaaaaaa hetmaaaaaaaa azylmaaaaaaaaa ogdmaaaaaaaaaa'"
      ]
     },
     "execution_count": 63,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "\"My solution\"\n",
    "def toGoatLatin(S):\n",
    "    words = S.split()\n",
    "    res = []\n",
    "    for i,word in enumerate(words):\n",
    "        if word[0] in 'aeiouAEIOU':\n",
    "            word = word+'ma'\n",
    "        else:\n",
    "            word = word[1:]+word[0]+'ma'\n",
    "        word = word+'a'*(i+1)\n",
    "        res.append(word)\n",
    "    return ' '.join(res)\n",
    "\n",
    "toGoatLatin(\"The quick brown fox jumped over the lazy dog\")"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 88,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "False"
      ]
     },
     "metadata": {},
     "output_type": "display_data"
    },
    {
     "data": {
      "text/plain": [
       "False"
      ]
     },
     "execution_count": 88,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "\"859. Buddy Strings\"\n",
    "\"\"\"Given two strings A and B of lowercase letters, return true if and only if we can swap two letters \n",
    "in A so that the result equals B.\n",
    "\n",
    "Example 1:\n",
    "\n",
    "Input: A = \"ab\", B = \"ba\"\n",
    "Output: true\n",
    "Example 2:\n",
    "\n",
    "Input: A = \"ab\", B = \"ab\"\n",
    "Output: false\n",
    "Example 3:\n",
    "\n",
    "Input: A = \"aa\", B = \"aa\"\n",
    "Output: true\n",
    "Example 4:\n",
    "\n",
    "Input: A = \"aaaaaaabc\", B = \"aaaaaaacb\"\n",
    "Output: true\n",
    "Example 5:\n",
    "\n",
    "Input: A = \"\", B = \"aa\"\n",
    "Output: false\"\"\"\n",
    "class Solution(object):\n",
    "    def buddyStrings(A, B):\n",
    "        if len(A) != len(B): return False\n",
    "        if A == B:\n",
    "            seen = set()\n",
    "            for a in A:\n",
    "                if a in seen:\n",
    "                    return True\n",
    "                seen.add(a)\n",
    "            return False\n",
    "        else:\n",
    "            pairs = []\n",
    "            for a, b in zip(A, B):\n",
    "                if a != b:\n",
    "                    pairs.append((a, b))\n",
    "                if len(pairs) >= 3: return False\n",
    "            return len(pairs) == 2 and pairs[0] == pairs[1][::-1]\n",
    "display(Solution.buddyStrings(\"ab\", \"ab\"))      \n",
    "\n",
    "\"My solution, slow\"\n",
    "class Solution:\n",
    "    import collections\n",
    "    from collections import Counter\n",
    "    def buddyStrings(A,B):\n",
    "        dicA = Counter(A)\n",
    "        dicB = Counter(B)\n",
    "        if dicA != dicB:\n",
    "            return False\n",
    "        elif A==B and all(dicA[i]==1 for i in A):\n",
    "            return False\n",
    "        count = 0\n",
    "        for i in range(len(A)):\n",
    "            if A[i] != B[i]:\n",
    "                count +=1\n",
    "        return count ==2 or count ==0\n",
    "Solution.buddyStrings(\"ab\", \"ab\")"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 89,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "{'acbd'}\n",
      "{'acbd'}\n",
      "{'acbd'}\n",
      "{'acbd', 'xzyz'}\n",
      "{'acbd', 'xzyz'}\n",
      "{'yzxz', 'acbd', 'xzyz'}\n"
     ]
    },
    {
     "data": {
      "text/plain": [
       "3"
      ]
     },
     "execution_count": 89,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "\"893. Groups of Special-Equivalent Strings\"\n",
    "\"\"\"You are given an array A of strings.\n",
    "\n",
    "A move onto S consists of swapping any two even indexed characters of S, or any two odd indexed characters of S.\n",
    "\n",
    "Two strings S and T are special-equivalent if after any number of moves onto S, S == T.\n",
    "\n",
    "For example, S = \"zzxy\" and T = \"xyzz\" are special-equivalent because we may make the moves \n",
    "\"zzxy\" -> \"xzzy\" -> \"xyzz\" that swap S[0] and S[2], then S[1] and S[3].\n",
    "\n",
    "Now, a group of special-equivalent strings from A is a non-empty subset of A such that:\n",
    "\n",
    "Every pair of strings in the group are special equivalent, and;\n",
    "The group is the largest size possible (ie., there isn't a string S not in the group such that S is \n",
    "special equivalent to every string in the group)\n",
    "Return the number of groups of special-equivalent strings from A.\n",
    "\n",
    " \n",
    "Example 1:\n",
    "\n",
    "Input: [\"abcd\",\"cdab\",\"cbad\",\"xyzz\",\"zzxy\",\"zzyx\"]\n",
    "Output: 3\n",
    "Explanation: \n",
    "One group is [\"abcd\", \"cdab\", \"cbad\"], since they are all pairwise special equivalent, \n",
    "and none of the other strings are all pairwise special equivalent to these.\n",
    "\n",
    "The other two groups are [\"xyzz\", \"zzxy\"] and [\"zzyx\"].  Note that in particular, \n",
    "\"zzxy\" is not special equivalent to \"zzyx\".\n",
    "Example 2:\n",
    "\n",
    "Input: [\"abc\",\"acb\",\"bac\",\"bca\",\"cab\",\"cba\"]\n",
    "Output: 3\"\"\"\n",
    "\"Sample solution\"\n",
    "class Solution(object):\n",
    "    def numSpecialEquivGroups(A):\n",
    "        \"\"\"\n",
    "        :type A: List[str]\n",
    "        :rtype: int\n",
    "        \"\"\"\n",
    "        B = set()\n",
    "        for a in A:\n",
    "            B.add(''.join(sorted(a[0::2])) + ''.join(sorted(a[1::2])))\n",
    "            print(B)\n",
    "        return len(B)\n",
    "Solution.numSpecialEquivGroups([\"abcd\",\"cdab\",\"cbad\",\"xyzz\",\"zzxy\",\"zzyx\"])"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 100,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "['a', 'b', 'C', 'd', 'E', 'f', 'g', 'h', 'I', 'j']\n"
     ]
    },
    {
     "data": {
      "text/plain": [
       "'j-Ih-gfE-dCba'"
      ]
     },
     "execution_count": 100,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "\"917. Reverse Only Letters\"\n",
    "\"\"\"Given a string S, return the \"reversed\" string where all characters that are not a letter stay in the same place, \n",
    "and all letters reverse their positions.\n",
    "\n",
    "Example 1:\n",
    "\n",
    "Input: \"ab-cd\"\n",
    "Output: \"dc-ba\"\n",
    "Example 2:\n",
    "\n",
    "Input: \"a-bC-dEf-ghIj\"\n",
    "Output: \"j-Ih-gfE-dCba\"\n",
    "Example 3:\n",
    "\n",
    "Input: \"Test1ng-Leet=code-Q!\"\n",
    "Output: \"Qedo1ct-eeLg=ntse-T!\"\"\"\n",
    "\"Sample solution\"\n",
    "class Solution(object):\n",
    "    def reverseOnlyLetters(S):\n",
    "        letters = [c for c in S if c.isalpha()]\n",
    "        print(letters)\n",
    "        ans = []\n",
    "        for c in S:\n",
    "            if c.isalpha():\n",
    "                ans.append(letters.pop())\n",
    "            else:\n",
    "                ans.append(c)\n",
    "        return \"\".join(ans)\n",
    "Solution.reverseOnlyLetters(\"a-bC-dEf-ghIj\")"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 134,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "True"
      ]
     },
     "execution_count": 134,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "\"925. Long Pressed Name\"\n",
    "\"\"\"Your friend is typing his name into a keyboard.  Sometimes, when typing a character c, \n",
    "the key might get long pressed, and the character will be typed 1 or more times.\n",
    "\n",
    "You examine the typed characters of the keyboard.  Return True if it is possible that it was your friends name, \n",
    "with some characters (possibly none) being long pressed.\n",
    "\n",
    "Example 1:\n",
    "\n",
    "Input: name = \"alex\", typed = \"aaleex\"\n",
    "Output: true\n",
    "Explanation: 'a' and 'e' in 'alex' were long pressed.\n",
    "Example 2:\n",
    "\n",
    "Input: name = \"saeed\", typed = \"ssaaedd\"\n",
    "Output: false\n",
    "Explanation: 'e' must have been pressed twice, but it wasn't in the typed output.\n",
    "Example 3:\n",
    "\n",
    "Input: name = \"leelee\", typed = \"lleeelee\"\n",
    "Output: true\n",
    "Example 4:\n",
    "\n",
    "Input: name = \"laiden\", typed = \"laiden\"\n",
    "Output: true\n",
    "Explanation: It's not necessary to long press any character.\"\"\"\n",
    "\"Sample solution\"\n",
    "class Solution:\n",
    "    def isLongPressedName(name, typed):\n",
    "\n",
    "        # two pointers to the \"name\" and \"typed\" string respectively\n",
    "        np, tp = 0, 0\n",
    "\n",
    "        # advance two pointers, until we exhaust one of the strings\n",
    "        while np < len(name) and tp < len(typed):\n",
    "            if name[np] == typed[tp]:\n",
    "                np += 1\n",
    "                tp += 1\n",
    "            elif tp >= 1 and typed[tp] == typed[tp-1]:\n",
    "                tp += 1\n",
    "            else:\n",
    "                return False\n",
    "\n",
    "        # if there is still some characters left *unmatched* in the origin string,\n",
    "        #   then we don't have a match.\n",
    "        # e.g.  name = \"abc\"  typed = \"aabb\"\n",
    "        if np != len(name):\n",
    "            return False\n",
    "        else:\n",
    "            # In the case that there are some redundant characters left in typed\n",
    "            # we could still have a match.\n",
    "            # e.g.  name = \"abc\"  typed = \"abccccc\"\n",
    "            while tp < len(typed):\n",
    "                if typed[tp] != typed[tp-1]:\n",
    "                    return False\n",
    "                tp += 1\n",
    "\n",
    "        # both strings have been consumed\n",
    "        return True\n",
    "Solution.isLongPressedName(\"leelee\",\"lleeelee\")"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 132,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "[('l', 1), ('e', 2), ('l', 1), ('e', 2)] [('l', 2), ('e', 3), ('l', 1), ('e', 2)]\n"
     ]
    },
    {
     "data": {
      "text/plain": [
       "True"
      ]
     },
     "execution_count": 132,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "\"My solution, slow\"\n",
    "def isLongPressedName(name, typed):\n",
    "    g1 = [(k, len(list(grp))) for k, grp in itertools.groupby(name)]\n",
    "    g2 = [(k, len(list(grp))) for k, grp in itertools.groupby(typed)]\n",
    "    print(g1,g2)\n",
    "    if len(g1) != len(g2):\n",
    "        return False\n",
    "\n",
    "    return all(k1 == k2 and v1 <= v2\n",
    "               for (k1,v1), (k2,v2) in zip(g1, g2))\n",
    "isLongPressedName(\"leelee\",\"lleeelee\")"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 136,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "2"
      ]
     },
     "execution_count": 136,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "\"929. Unique Email Addresses\"\n",
    "\"\"\"Every email consists of a local name and a domain name, separated by the @ sign.\n",
    "\n",
    "For example, in alice@leetcode.com, alice is the local name, and leetcode.com is the domain name.\n",
    "\n",
    "Besides lowercase letters, these emails may contain '.'s or '+'s.\n",
    "\n",
    "If you add periods ('.') between some characters in the local name part of an email address, \n",
    "mail sent there will be forwarded to the same address without dots in the local name.  \n",
    "For example, \"alice.z@leetcode.com\" and \"alicez@leetcode.com\" forward to the same email address.  \n",
    "(Note that this rule does not apply for domain names.)\n",
    "\n",
    "If you add a plus ('+') in the local name, everything after the first plus sign will be ignored. \n",
    "This allows certain emails to be filtered, for example m.y+name@email.com will be forwarded to my@email.com.  \n",
    "(Again, this rule does not apply for domain names.)\n",
    "\n",
    "It is possible to use both of these rules at the same time.\n",
    "\n",
    "Given a list of emails, we send one email to each address in the list.  \n",
    "How many different addresses actually receive mails? \n",
    "\n",
    "Example 1:\n",
    "\n",
    "Input: [\"test.email+alex@leetcode.com\",\"test.e.mail+bob.cathy@leetcode.com\",\"testemail+david@lee.tcode.com\"]\n",
    "Output: 2\n",
    "Explanation: \"testemail@leetcode.com\" and \"testemail@lee.tcode.com\" actually receive mails\"\"\"\n",
    "\"Sample solution\"\n",
    "class Solution(object):\n",
    "    def numUniqueEmails(emails):\n",
    "        seen = set()\n",
    "        for email in emails:\n",
    "            local, domain = email.split('@')\n",
    "            if '+' in local:\n",
    "                local = local[:local.index('+')]\n",
    "            seen.add(local.replace('.','') + '@' + domain)\n",
    "        return len(seen)\n",
    "Solution.numUniqueEmails([\"test.email+alex@leetcode.com\",\"test.e.mail+bob.cathy@leetcode.com\",\"testemail+david@lee.tcode.com\"])"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 139,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "(1,)\n",
      "(0, 'art can', 'let1')\n",
      "(1,)\n",
      "(0, 'own kit dig', 'let2')\n",
      "(0, 'art zero', 'let3')\n"
     ]
    },
    {
     "data": {
      "text/plain": [
       "['let1 art can',\n",
       " 'let3 art zero',\n",
       " 'let2 own kit dig',\n",
       " 'dig1 8 1 5 1',\n",
       " 'dig2 3 6']"
      ]
     },
     "execution_count": 139,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "\"937. Reorder Data in Log Files\"\n",
    "\"\"\"You have an array of logs.  Each log is a space delimited string of words.\n",
    "\n",
    "For each log, the first word in each log is an alphanumeric identifier.  Then, either:\n",
    "\n",
    "Each word after the identifier will consist only of lowercase letters, or;\n",
    "Each word after the identifier will consist only of digits.\n",
    "We will call these two varieties of logs letter-logs and digit-logs.  \n",
    "It is guaranteed that each log has at least one word after its identifier.\n",
    "\n",
    "Reorder the logs so that all of the letter-logs come before any digit-log.  \n",
    "The letter-logs are ordered lexicographically ignoring identifier, with the identifier used in case of ties.  \n",
    "The digit-logs should be put in their original order.\n",
    "\n",
    "Return the final order of the logs.\n",
    "\n",
    "Example 1:\n",
    "\n",
    "Input: logs = [\"dig1 8 1 5 1\",\"let1 art can\",\"dig2 3 6\",\"let2 own kit dig\",\"let3 art zero\"]\n",
    "Output: [\"let1 art can\",\"let3 art zero\",\"let2 own kit dig\",\"dig1 8 1 5 1\",\"dig2 3 6\"]\"\"\"\n",
    "\n",
    "\"Sample solution\"\n",
    "class Solution(object):\n",
    "    def reorderLogFiles(logs):\n",
    "        def f(log):\n",
    "            id_, rest = log.split(\" \", 1)    #,1 只split第一个词\n",
    "            print((0, rest, id_) if rest[0].isalpha() else (1,))\n",
    "            return (0, rest, id_) if rest[0].isalpha() else (1,)\n",
    "        return sorted(logs, key = f)\n",
    "Solution.reorderLogFiles([\"dig1 8 1 5 1\",\"let1 art can\",\"dig2 3 6\",\"let2 own kit dig\",\"let3 art zero\"])"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 140,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "['let1', 'art can']"
      ]
     },
     "execution_count": 140,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "'let1 art can'.split(' ',1)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": []
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.6.8"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 2
}
