{
 "cells": [
  {
   "cell_type": "code",
   "execution_count": 16,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "[6, 4, 7, 5, 3, 2, 1]\n"
     ]
    },
    {
     "data": {
      "text/plain": [
       "-6475321"
      ]
     },
     "execution_count": 16,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "\"7. Reverse Integer\"\n",
    "\"\"\"Given a 32-bit signed integer, reverse digits of an integer.\n",
    "\n",
    "Example 1:\n",
    "\n",
    "Input: 123\n",
    "Output: 321\n",
    "Example 2:\n",
    "\n",
    "Input: -123\n",
    "Output: -321\n",
    "Example 3:\n",
    "\n",
    "Input: 120\n",
    "Output: 21\n",
    "Note:\n",
    "Assume we are dealing with an environment which could only store integers within the 32-bit signed integer range:\n",
    "[−231,  231 − 1]. For the purpose of this problem, assume that your function returns 0 when the reversed integer \n",
    "overflows.\"\"\"\n",
    "class Solution(object):\n",
    "    def reverse(x):\n",
    "        \"\"\"\n",
    "        :type x: int\n",
    "        :rtype: int\n",
    "        \"\"\"\n",
    "        sign = 1 if x>0 else -1\n",
    "        x = abs(x)\n",
    "        \n",
    "        stack = []\n",
    "        while x>=1:\n",
    "            stack.append(x%10)\n",
    "            x = x // 10\n",
    "        res = 0\n",
    "        i = 0\n",
    "        print(stack)\n",
    "        while stack:\n",
    "            res += stack.pop() * 10**i\n",
    "            i += 1\n",
    "        return res*sign*(res<2**31)\n",
    "Solution.reverse(-1235746)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 12,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "-321"
      ]
     },
     "execution_count": 12,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "\"My solution\"\n",
    "def reverse(x):\n",
    "    if x<0:\n",
    "        a= -1*int(str(x)[1:][::-1])\n",
    "    if x>=0:\n",
    "        a= int(str(x)[::-1]) \n",
    "    # handle 32 bit overflow  \n",
    "    mina = -2**31  \n",
    "    maxa = 2**31 - 1  \n",
    "    if a not in range(mina, maxa):  \n",
    "        return 0  \n",
    "    else:  \n",
    "        return a\n",
    "reverse(-123)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 18,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "False"
      ]
     },
     "execution_count": 18,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "\"9. Palindrome Number\"\n",
    "\"\"\"Determine whether an integer is a palindrome. An integer is a palindrome when it reads the same backward as forward.\n",
    "\n",
    "Example 1:\n",
    "\n",
    "Input: 121\n",
    "Output: true\n",
    "Example 2:\n",
    "\n",
    "Input: -121\n",
    "Output: false\n",
    "Explanation: From left to right, it reads -121. From right to left, it becomes 121-. Therefore it is not a palindrome.\n",
    "Example 3:\n",
    "\n",
    "Input: 10\n",
    "Output: false\n",
    "Explanation: Reads 01 from right to left. Therefore it is not a palindrome.\n",
    "\"\"\"\n",
    "class Solution:\n",
    "    def isPalindrome(x):\n",
    "        return str(x)==str(x)[::-1]\n",
    "Solution.isPalindrome(-121)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 23,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "165\n",
      "83\n",
      "43\n",
      "25\n",
      "19\n",
      "18\n"
     ]
    },
    {
     "data": {
      "text/plain": [
       "18"
      ]
     },
     "execution_count": 23,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "\"69. Sqrt(x)\"\n",
    "\"\"\"Implement int sqrt(int x).\n",
    "\n",
    "Compute and return the square root of x, where x is guaranteed to be a non-negative integer.\n",
    "\n",
    "Since the return type is an integer, the decimal digits are truncated and only the integer part of\n",
    "the result is returned.\n",
    "\n",
    "Example 1:\n",
    "\n",
    "Input: 4\n",
    "Output: 2\n",
    "Example 2:\n",
    "\n",
    "Input: 8\n",
    "Output: 2\n",
    "Explanation: The square root of 8 is 2.82842..., and since \n",
    "             the decimal part is truncated, 2 is returned.\"\"\"\n",
    "\"sample solution\"\n",
    "\"\"\"牛顿迭代:\n",
    "问题为，其中是常数，是未知数，将其改写为习惯的数学形式：\n",
    "\n",
    "目标就变成了找到一个使\n",
    "自然想到了牛顿迭代法：\n",
    "把在某一点的邻域内展开成泰勒级数，取其线性部分，并令其等于0：\n",
    "\n",
    "得到迭代关系式：\n",
    "\n",
    "因为不用求精确解，所以迭代到不大于时停止即可\n",
    "\n",
    "初值可以设置为\n",
    "\n",
    "作者：wzNote\n",
    "链接：https://www.jianshu.com/p/e6dd97bbcd40\n",
    "来源：简书\n",
    "著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。\"\"\"\n",
    "class Solution:\n",
    "    def mySqrt(x):\n",
    "        \"\"\"\n",
    "        :type x: int\n",
    "        :rtype: int\n",
    "        \"\"\"\n",
    "        r = x\n",
    "        while r*r > x:\n",
    "            r = int((r + x/r) / 2)\n",
    "            print(r)\n",
    "        return r\n",
    "Solution.mySqrt(329)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 22,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "18"
      ]
     },
     "execution_count": 22,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "\"My Solution, too slow\"\n",
    "def mySqrt(x):\n",
    "    i = 0\n",
    "    while i**2 <= x:\n",
    "        i += 1\n",
    "    return i-1\n",
    "mySqrt(329)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 31,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "['N']\n",
      "['N', 'M']\n"
     ]
    },
    {
     "data": {
      "text/plain": [
       "'CMN'"
      ]
     },
     "execution_count": 31,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "\"168. Excel Sheet Column Title\"\n",
    "\"\"\"Given a positive integer, return its corresponding column title as appear in an Excel sheet.\n",
    "\n",
    "For example:\n",
    "\n",
    "    1 -> A\n",
    "    2 -> B\n",
    "    3 -> C\n",
    "    ...\n",
    "    26 -> Z\n",
    "    27 -> AA\n",
    "    28 -> AB \n",
    "    ...\n",
    "Example 1:\n",
    "\n",
    "Input: 1\n",
    "Output: \"A\"\n",
    "Example 2:\n",
    "\n",
    "Input: 28\n",
    "Output: \"AB\"\n",
    "Example 3:\n",
    "\n",
    "Input: 701\n",
    "Output: \"ZY\"\"\"\n",
    "\"Sample solution, 与十进制同理，先除10得余数\"\n",
    "class Solution(object):\n",
    "    def convertToTitle(n):\n",
    "        \"\"\"\n",
    "        :type n: int\n",
    "        :rtype: str\n",
    "        \"\"\"\n",
    "        if n <= 0:\n",
    "            return \"\"\n",
    "\n",
    "        A = ord('A')\n",
    "        res = []\n",
    "        while n > 0:\n",
    "            if n > 26:\n",
    "                i = n % 26\n",
    "                if i == 0:\n",
    "                    res.append('Z')\n",
    "                    n -= 26\n",
    "                else:\n",
    "                    res.append(chr(A + i - 1))\n",
    "                    print(res)\n",
    "                n //= 26\n",
    "            else:\n",
    "                res.append(chr(A + n - 1))\n",
    "                break\n",
    "        res.reverse()\n",
    "        return ''.join(res)\n",
    "Solution.convertToTitle(2380)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 33,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "731"
      ]
     },
     "execution_count": 33,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "\"171. Excel Sheet Column Number\"\n",
    "\"\"\"Given a column title as appear in an Excel sheet, return its corresponding column number.\n",
    "\n",
    "For example:\n",
    "\n",
    "    A -> 1\n",
    "    B -> 2\n",
    "    C -> 3\n",
    "    ...\n",
    "    Z -> 26\n",
    "    AA -> 27\n",
    "    AB -> 28 \n",
    "    ...\n",
    "Example 1:\n",
    "\n",
    "Input: \"A\"\n",
    "Output: 1\n",
    "Example 2:\n",
    "\n",
    "Input: \"AB\"\n",
    "Output: 28\n",
    "Example 3:\n",
    "\n",
    "Input: \"ZY\"\n",
    "Output: 701\"\"\"\n",
    "\"Sample solution\"\n",
    "class Solution(object):\n",
    "    def titleToNumber(s):\n",
    "        \"\"\"\n",
    "        :type s: str\n",
    "        :rtype: int\n",
    "        \"\"\"\n",
    "        suma = 0\n",
    "        for c in s:\n",
    "            suma = suma*26 + ord(c) - 64 # 64 = ord('A') - 1\n",
    "        return suma\n",
    "Solution.titleToNumber('ABC')"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 42,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "2"
      ]
     },
     "execution_count": 42,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "\"172. Factorial Trailing Zeroes\"\n",
    "\"\"\"Given an integer n, return the number of trailing zeroes in n!.\n",
    "\n",
    "Example 1:\n",
    "\n",
    "Input: 3\n",
    "Output: 0\n",
    "Explanation: 3! = 6, no trailing zero.\n",
    "Example 2:\n",
    "\n",
    "Input: 5\n",
    "Output: 1\n",
    "Explanation: 5! = 120, one trailing zero.\"\"\"\n",
    "\"Sample solution\"\n",
    "\"\"\"所有的尾部的0可以看做都是2*5得来的，所以通过计算所有的因子中2和5的个数就可以知道尾部0的个数。\n",
    "实际上，2的个数肯定是足够的，所以只需计算5的个数即可。\n",
    "要注意，25=5*5是有两个5的因子；125=5*5*5有3个5的因子。比如，计算135!末尾0的个数。\n",
    "首先135/5 = 27，说明135以内有27个5的倍数；27/5=5，说明135以内有5个25的倍数；5/5=1，说明135以内有1个125的倍数。\n",
    "当然其中有重复计数，算下来135以内因子5的个数为27+5+1=33。\"\"\"\n",
    "class Solution(object):\n",
    "    def trailingZeroes(n):\n",
    "        \"\"\"\n",
    "        :type n: int\n",
    "        :rtype: int\n",
    "        \"\"\"\n",
    "        res = 0\n",
    "        while n > 0:\n",
    "            n = n//5\n",
    "            res += n\n",
    "        return res\n",
    "Solution.trailingZeroes(12)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 43,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "2"
      ]
     },
     "execution_count": 43,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "\"My solution, exceed time limit\"\n",
    "def trailingZeroes(n):\n",
    "    res = 1\n",
    "    while n >0:\n",
    "        res = res*n\n",
    "        n -= 1\n",
    "    count = 0\n",
    "    while res%10 ==0:\n",
    "        res //=10\n",
    "        count += 1\n",
    "    return count\n",
    "trailingZeroes(12)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 50,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "True"
      ]
     },
     "metadata": {},
     "output_type": "display_data"
    },
    {
     "data": {
      "text/plain": [
       "True"
      ]
     },
     "execution_count": 50,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "\"231. Power of Two\"\n",
    "\"\"\"Given an integer, write a function to determine if it is a power of two.\n",
    "\n",
    "Example 1:\n",
    "\n",
    "Input: 1\n",
    "Output: true \n",
    "Explanation: 2^0 = 1\n",
    "Example 2:\n",
    "\n",
    "Input: 16\n",
    "Output: true\n",
    "Explanation: 2^4 = 16\n",
    "Example 3:\n",
    "\n",
    "Input: 218\n",
    "Output: false\"\"\"\n",
    "\"Sample solution\"\n",
    "\"\"\"注意到2的幂次 x 表示成二进制一定是一个1后面若干个0，那么只要计算输入数的二进制表示是否只有一个1即可。\"\"\"\n",
    "class Solution(object):\n",
    "    def isPowerOfTwo(n):\n",
    "        return n > 0 and bin(n).count('1') == 1\n",
    "display(Solution.isPowerOfTwo(8))\n",
    "\n",
    "\"\"\"2的幂次 x 表示成二进制一定是一个1后面若干个0，那么 x-1 一定是一个0后面若干个1，所以 x & (x-1) = 0 ，非2的幂无法得到0。\"\"\"\n",
    "class Solution(object):\n",
    "    def isPowerOfTwo(n):\n",
    "        return n > 0 and not (n & n-1)   # & is bitwiseAND 二进制法里的and\n",
    "Solution.isPowerOfTwo(8)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 48,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "True"
      ]
     },
     "execution_count": 48,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "\"My solution, too slow\"\n",
    "def isPowerOfTwo(n):\n",
    "    if n < 1:\n",
    "        return False\n",
    "    while n%2 == 0:\n",
    "        n /= 2\n",
    "    return True if n==1 else False\n",
    "isPowerOfTwo(8)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 55,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "2"
      ]
     },
     "metadata": {},
     "output_type": "display_data"
    },
    {
     "data": {
      "text/plain": [
       "5"
      ]
     },
     "execution_count": 55,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "\"258. Add Digits\"\n",
    "\"\"\"Given a non-negative integer num, repeatedly add all its digits until the result has only one digit.\n",
    "\n",
    "Example:\n",
    "\n",
    "Input: 38\n",
    "Output: 2 \n",
    "Explanation: The process is like: 3 + 8 = 11, 1 + 1 = 2. \n",
    "             Since 2 has only one digit, return it.\"\"\"\n",
    "\"Sample solution\"\n",
    "\"\"\"根据提示，当输入从1到100变化时，可以发现，输出在“1，2，3，4，5，6，7，8，9，1，2，3，4，5，6，7，8，9，…”这样循环。\n",
    "于是，就有了下面O(1)的算法。\n",
    "dr(n) = 0, if n = 0\n",
    "dr(n) = 9, if n != 0 and n mod 9 == 0\n",
    "dr(n) = n mod 9, if n mod 9 != 0\n",
    "或，\n",
    "dr(n) = 1 + (n-1) mod 9\"\"\"\n",
    "class Solution:\n",
    "    def addDigits(num):\n",
    "        if num == 0:\n",
    "            return 0\n",
    "        if num % 9 == 0:\n",
    "            return 9\n",
    "        return num % 9\n",
    "\n",
    "class Solution(object):\n",
    "    def addDigits(num):\n",
    "        if num == 0:\n",
    "            return 0\n",
    "        else:\n",
    "            return 1 + (num - 1) % 9\n",
    "display(Solution.addDigits(29))\n",
    "\n",
    "\"More complicated, slow\"\n",
    "class Solution:\n",
    "    def addDigits(num):\n",
    "        digital_root = 0\n",
    "        while num > 0:\n",
    "            digital_root += num % 10\n",
    "            num = num // 10\n",
    "            \n",
    "            if num == 0 and digital_root > 9:\n",
    "                num = digital_root\n",
    "                digital_root = 0\n",
    "                \n",
    "        return digital_root\n",
    "Solution.addDigits(2930)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 56,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "False"
      ]
     },
     "execution_count": 56,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "\"263. Ugly Number\"\n",
    "\"\"\"Write a program to check whether a given number is an ugly number.\n",
    "\n",
    "Ugly numbers are positive numbers whose prime factors only include 2, 3, 5.\n",
    "\n",
    "Example 1:\n",
    "\n",
    "Input: 6\n",
    "Output: true\n",
    "Explanation: 6 = 2 × 3\n",
    "Example 2:\n",
    "\n",
    "Input: 8\n",
    "Output: true\n",
    "Explanation: 8 = 2 × 2 × 2\n",
    "Example 3:\n",
    "\n",
    "Input: 14\n",
    "Output: false \n",
    "Explanation: 14 is not ugly since it includes another prime factor 7.\"\"\"\n",
    "\"Sample solution\"\n",
    "class Solution(object):\n",
    "    def isUgly(num):\n",
    "        if num<=0:\n",
    "            return False\n",
    "        for i in [2, 3, 5]:\n",
    "            while num % i == 0:\n",
    "                num /= i\n",
    "        return num == 1\n",
    "Solution.isUgly(78)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 57,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "True"
      ]
     },
     "execution_count": 57,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "\"326. Power of Three\"\n",
    "\"\"\"Given an integer, write a function to determine if it is a power of three.\n",
    "\n",
    "Example 1:\n",
    "\n",
    "Input: 27\n",
    "Output: true\n",
    "Example 2:\n",
    "\n",
    "Input: 0\n",
    "Output: false\n",
    "Example 3:\n",
    "\n",
    "Input: 9\n",
    "Output: true\n",
    "Example 4:\n",
    "\n",
    "Input: 45\n",
    "Output: false\"\"\"\n",
    "class Solution:\n",
    "    def isPowerOfThree(n):\n",
    "        if n < 1:\n",
    "            return False\n",
    "        while n%3 == 0:\n",
    "            n /= 3\n",
    "        return n==1\n",
    "Solution.isPowerOfThree(27)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 59,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "True"
      ]
     },
     "execution_count": 59,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "\"367. Valid Perfect Square\"\n",
    "\"\"\"Given a positive integer num, write a function which returns True if num is a perfect square else False.\n",
    "\n",
    "Follow up: Do not use any built-in library function such as sqrt.\n",
    "\n",
    "Example 1:\n",
    "\n",
    "Input: num = 16\n",
    "Output: true\n",
    "Example 2:\n",
    "\n",
    "Input: num = 14\n",
    "Output: false\"\"\"\n",
    "\"Sample solution, 一个完全平方数是从1开始的若干连续奇数的和。\"\n",
    "class Solution(object):\n",
    "    def isPerfectSquare(num):\n",
    "        \"\"\"\n",
    "        :type num: int\n",
    "        :rtype: bool\n",
    "        \"\"\"\n",
    "        i = 1\n",
    "        while num > 0:\n",
    "            num -= i\n",
    "            i += 2\n",
    "        return num == 0\n",
    "Solution.isPerfectSquare(25)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 67,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "10"
      ]
     },
     "metadata": {},
     "output_type": "display_data"
    },
    {
     "data": {
      "text/plain": [
       "11"
      ]
     },
     "execution_count": 67,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "\"441. Arranging Coins\"\n",
    "\"\"\"You have a total of n coins that you want to form in a staircase shape, \n",
    "where every k-th row must have exactly k coins.\n",
    "\n",
    "Given n, find the total number of full staircase rows that can be formed.\n",
    "\n",
    "n is a non-negative integer and fits within the range of a 32-bit signed integer.\n",
    "\n",
    "Example 1:\n",
    "\n",
    "n = 5\n",
    "\n",
    "The coins can form the following rows:\n",
    "¤\n",
    "¤ ¤\n",
    "¤ ¤\n",
    "\n",
    "Because the 3rd row is incomplete, we return 2.\n",
    "Example 2:\n",
    "\n",
    "n = 8\n",
    "\n",
    "The coins can form the following rows:\n",
    "¤\n",
    "¤ ¤\n",
    "¤ ¤ ¤\n",
    "¤ ¤\n",
    "\n",
    "Because the 4th row is incomplete, we return 3.\"\"\"\n",
    "\"Sample solution\"\n",
    "\"\"\"二分查找\n",
    "上面做法的效率不高。因为前k层的硬币个数可以直接通过(k + 1) * k / 2求出来，所以很直接的想法就可以使用二分查找。\n",
    "\n",
    "即目的是找到(k + 1) * k / 2<=sum的最大数字，套用二分查找的模板，很容易写出来。\"\"\"\n",
    "class Solution:\n",
    "    def arrangeCoins(n):\n",
    "        left, right = 0, n\n",
    "        while left <= right:\n",
    "            k = (right + left) // 2\n",
    "            curr = k * (k + 1) // 2\n",
    "            if curr == n:\n",
    "                return k\n",
    "            if n < curr:\n",
    "                right = k - 1\n",
    "            else:\n",
    "                left = k + 1\n",
    "        return right\n",
    "display(Solution.arrangeCoins(59))\n",
    "\n",
    "\"\"\"数学公式\n",
    "刷题的时候第一次遇到纯数学的问题，其实就是求解sum = (x + 1) * x / 2这个方程，很简单的就能得到x = (-1 + sqrt(8 * n + 1)) / 2，\n",
    "向下取整就能得到结果了。\"\"\"\n",
    "class Solution:\n",
    "    def arrangeCoins(n):\n",
    "        return int((2 * n + 0.25)**0.5 - 0.5)\n",
    "Solution.arrangeCoins(69)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 66,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "11"
      ]
     },
     "execution_count": 66,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "\"My solution, toooooo slow\"\n",
    "def arrangeCoins(n):\n",
    "    i = 0\n",
    "    while n > i:\n",
    "        i +=1\n",
    "        n -= i\n",
    "    return i\n",
    "arrangeCoins(69)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 68,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "3"
      ]
     },
     "execution_count": 68,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "\"453. Minimum Moves to Equal Array Elements\"\n",
    "\"\"\"Given a non-empty integer array of size n, find the minimum number of moves required to \n",
    "make all array elements equal, where a move is incrementing n - 1 elements by 1.\n",
    "\n",
    "Example:\n",
    "\n",
    "Input:\n",
    "[1,2,3]\n",
    "\n",
    "Output:\n",
    "3\n",
    "\n",
    "Explanation:\n",
    "Only three moves are needed (remember each move increments two elements):\n",
    "\n",
    "[1,2,3]  =>  [2,3,3]  =>  [3,4,3]  =>  [4,4,4]\"\"\"\n",
    "\"Sample solution\"\n",
    "\"\"\"把其中最小的n-1个元素都++ 相当于 把最大的元素–；\n",
    "\n",
    "我们的目标是把所有的元素搞相等，也就是每次把最大的元素-1 直到所有元素都等于最小元素即可。\n",
    "\n",
    "故总的运算次数等于 所有元素与最小元素 的差 的和： sum(array) - n * minimum\"\"\"\n",
    "class Solution:\n",
    "    def minMoves(nums):\n",
    "        \"\"\"\n",
    "        :type nums: List[int]\n",
    "        :rtype: int\n",
    "        \"\"\"\n",
    "        return sum(nums) - len(nums) * min(nums)\n",
    "Solution.minMoves([1,2,3])"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 71,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "True"
      ]
     },
     "execution_count": 71,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "\"507. Perfect Number\"\n",
    "\"\"\"We define the Perfect Number is a positive integer that is equal to the sum of all its \n",
    "positive divisors except itself.\n",
    "\n",
    "Now, given an integer n, write a function that returns true when it is a perfect number and false when it is not.\n",
    "Example:\n",
    "\n",
    "Input: 28\n",
    "Output: True\n",
    "Explanation: 28 = 1 + 2 + 4 + 7 + 14\n",
    "Note: The input number n will not exceed 100,000,000. (1e8)\"\"\"\n",
    "\"Sample solution\"\n",
    "class Solution(object):\n",
    "    def checkPerfectNumber(num):\n",
    "        import math\n",
    "        \"\"\"\n",
    "        :type num: int\n",
    "        :rtype: bool\n",
    "        \"\"\"\n",
    "        if num <= 1: return False\n",
    "        sums = 1\n",
    "        for i in range(2, int(math.sqrt(num) + 1)):\n",
    "            if num % i == 0:\n",
    "                sums += i + num / i\n",
    "        return num == sums\n",
    "Solution.checkPerfectNumber(28)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 73,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "4"
      ]
     },
     "execution_count": 73,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "\"598. Range Addition II\"\n",
    "\"\"\"Given an m * n matrix M initialized with all 0's and several update operations.\n",
    "\n",
    "Operations are represented by a 2D array, and each operation is represented by an array with two \n",
    "positive integers a and b, which means M[i][j] should be added by one for all 0 <= i < a and 0 <= j < b.\n",
    "\n",
    "You need to count and return the number of maximum integers in the matrix after performing all the operations.\n",
    "\n",
    "Example 1:\n",
    "\n",
    "Input: \n",
    "m = 3, n = 3\n",
    "operations = [[2,2],[3,3]]\n",
    "Output: 4\n",
    "Explanation: \n",
    "Initially, M = \n",
    "[[0, 0, 0],\n",
    " [0, 0, 0],\n",
    " [0, 0, 0]]\n",
    "\n",
    "After performing [2,2], M = \n",
    "[[1, 1, 0],\n",
    " [1, 1, 0],\n",
    " [0, 0, 0]]\n",
    "\n",
    "After performing [3,3], M = \n",
    "[[2, 2, 1],\n",
    " [2, 2, 1],\n",
    " [1, 1, 1]]\n",
    "\n",
    "So the maximum integer in M is 2, and there are four of it in M. So return 4.\"\"\"\n",
    "\"Sample solution\"\n",
    "\"\"\"首先要明白，要求的结果是最终二维数组中最大值出现的次数。那么，被重复加的最多的数组元素一定最大，其出现次数就是答案。\n",
    "\n",
    "每次操作都是对左上角部分区域进行操作的，并且，a,b的范围都是大于1的，即每次都会有元素改变。那么，最终二维数组中最大值出现的次数\n",
    "一定是操作中最小范围中的那批元素构成的矩形区域面积。\n",
    "\n",
    "如果没有进行操作，那么，返回的应该是全部0的个数。\"\"\"\n",
    "class Solution(object):\n",
    "    def maxCount( m, n, ops):\n",
    "        \"\"\"\n",
    "        :type m: int\n",
    "        :type n: int\n",
    "        :type ops: List[List[int]]\n",
    "        :rtype: int\n",
    "        \"\"\"\n",
    "        if not ops:\n",
    "            return m * n\n",
    "        return min([op[0] for op in ops]) * min([op[1] for op in ops])\n",
    "Solution.maxCount(3, 3, [[2,2],[3,3]])"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 80,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "False"
      ]
     },
     "metadata": {},
     "output_type": "display_data"
    },
    {
     "data": {
      "text/plain": [
       "True"
      ]
     },
     "execution_count": 80,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "\"633. Sum of Square Numbers\"\n",
    "\"\"\"Given a non-negative integer c, your task is to decide whether there're two integers a and b\n",
    "such that a2 + b2 = c.\n",
    "\n",
    "Example 1:\n",
    "\n",
    "Input: 5\n",
    "Output: True\n",
    "Explanation: 1 * 1 + 2 * 2 = 5\n",
    " \n",
    "\n",
    "Example 2:\n",
    "\n",
    "Input: 3\n",
    "Output: False\"\"\"\n",
    "\"Sample solution, 双指针,两个指针向中间靠拢\"\n",
    "class Solution(object):\n",
    "    def judgeSquareSum(c):\n",
    "        \"\"\"\n",
    "        :type c: int\n",
    "        :rtype: bool\n",
    "        \"\"\"\n",
    "        left = 0\n",
    "        right = int(c ** 0.5)\n",
    "        while left <= right:\n",
    "            cur = left ** 2 + right ** 2\n",
    "            if cur < c:\n",
    "                left += 1\n",
    "            elif cur > c:\n",
    "                right -= 1\n",
    "            else:\n",
    "                return True\n",
    "        return False\n",
    "display(Solution.judgeSquareSum(35))\n",
    "    \n",
    "\"Sample solution\"\n",
    "\"\"\"使用循环进行判断，看是不是有一个a存在，使得c - a ^ 2是个完全平方数。\n",
    "\n",
    "判断一个数是不是完全平方数，方法很多，我用的是最简单的，先取根号，然后再平方看是否相等的方式。\"\"\"\n",
    "class Solution(object):\n",
    "    def judgeSquareSum(c):\n",
    "        import math\n",
    "        \"\"\"\n",
    "        :type c: int\n",
    "        :rtype: bool\n",
    "        \"\"\"\n",
    "        if c == 0: return True\n",
    "        for a in range(1, int(math.sqrt(c) + 1)):\n",
    "            b = c - a * a\n",
    "            if int(math.sqrt(b)) ** 2 == b:\n",
    "                return True\n",
    "        return False\n",
    "Solution.judgeSquareSum(49)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 96,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "[1, 2, 3, 4, 5, 6, 7, 8, 9, 11, 12, 15, 22]"
      ]
     },
     "execution_count": 96,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "\"728. Self Dividing Numbers\"\n",
    "\"\"\"A self-dividing number is a number that is divisible by every digit it contains.\n",
    "\n",
    "For example, 128 is a self-dividing number because 128 % 1 == 0, 128 % 2 == 0, and 128 % 8 == 0.\n",
    "\n",
    "Also, a self-dividing number is not allowed to contain the digit zero.\n",
    "\n",
    "Given a lower and upper number bound, output a list of every possible self dividing number, \n",
    "including the bounds if possible.\n",
    "\n",
    "Example 1:\n",
    "\n",
    "Input: \n",
    "left = 1, right = 22\n",
    "Output: [1, 2, 3, 4, 5, 6, 7, 8, 9, 11, 12, 15, 22]\"\"\"\n",
    "\"My solution\"\n",
    "class Solution:\n",
    "    def selfDividingNumbers(left,right):\n",
    "        res = []\n",
    "        for i in range(left,right+1):\n",
    "            if '0' in str(i):\n",
    "                continue\n",
    "            else:\n",
    "                if all(i % int(k) == 0 for k in str(i)):\n",
    "                    res.append(i)\n",
    "        return res\n",
    "Solution.selfDividingNumbers(1,22)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 99,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "2.0"
      ]
     },
     "execution_count": 99,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "\"812. Largest Triangle Area\"\n",
    "\"\"\"You have a list of points in the plane. Return the area of the largest triangle that can be \n",
    "formed by any 3 of the points.\n",
    "\n",
    "Example:\n",
    "Input: points = [[0,0],[0,1],[1,0],[0,2],[2,0]]\n",
    "Output: 2\n",
    "Explanation: \n",
    "The five points are show in the figure below. The red triangle is the largest.\"\"\"\n",
    "\"Sample solution, A = 1/2* [x1*(y2-y3)+x2*(y3-y1)+x3*(y1-y2)]\"\n",
    "class Solution(object):\n",
    "    def largestTriangleArea(points):\n",
    "        import itertools\n",
    "        def area(p, q, r):\n",
    "            return .5 * abs(p[0]*q[1]+q[0]*r[1]+r[0]*p[1]\n",
    "                           -p[1]*q[0]-q[1]*r[0]-r[1]*p[0])\n",
    "\n",
    "        return max(area(*triangle)\n",
    "            for triangle in itertools.combinations(points, 3))\n",
    "Solution.largestTriangleArea([[0,0],[0,1],[1,0],[0,2],[2,0]])"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 100,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "True"
      ]
     },
     "execution_count": 100,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "\"836. Rectangle Overlap\"\n",
    "\"\"\"A rectangle is represented as a list [x1, y1, x2, y2], where (x1, y1) are the coordinates \n",
    "of its bottom-left corner, and (x2, y2) are the coordinates of its top-right corner.\n",
    "\n",
    "Two rectangles overlap if the area of their intersection is positive.  To be clear, two rectangles \n",
    "that only touch at the corner or edges do not overlap.\n",
    "\n",
    "Given two (axis-aligned) rectangles, return whether they overlap.\n",
    "\n",
    "Example 1:\n",
    "\n",
    "Input: rec1 = [0,0,2,2], rec2 = [1,1,3,3]\n",
    "Output: true\n",
    "Example 2:\n",
    "\n",
    "Input: rec1 = [0,0,1,1], rec2 = [1,0,2,1]\n",
    "Output: false\"\"\"\n",
    "\"Sample solution\"\n",
    "class Solution(object):\n",
    "    def isRectangleOverlap(rec1, rec2):\n",
    "        return not (rec1[2] <= rec2[0] or  # left\n",
    "                    rec1[3] <= rec2[1] or  # bottom\n",
    "                    rec1[0] >= rec2[2] or  # right\n",
    "                    rec1[1] >= rec2[3])    # top\n",
    "Solution.isRectangleOverlap([0,0,2,2], [1,1,3,3])"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 102,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "4"
      ]
     },
     "execution_count": 102,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "\"868. Binary Gap\"\n",
    "\"\"\"Given a positive integer N, find and return the longest distance between two consecutive 1's \n",
    "in the binary representation of N.\n",
    "\n",
    "If there aren't two consecutive 1's, return 0.\n",
    "\n",
    "Example 1:\n",
    "\n",
    "Input: 22\n",
    "Output: 2\n",
    "Explanation: \n",
    "22 in binary is 0b10110.\n",
    "In the binary representation of 22, there are three ones, and two consecutive pairs of 1's.\n",
    "The first consecutive pair of 1's have distance 2.\n",
    "The second consecutive pair of 1's have distance 1.\n",
    "The answer is the largest of these two distances, which is 2.\n",
    "Example 2:\n",
    "\n",
    "Input: 5\n",
    "Output: 2\n",
    "Explanation: \n",
    "5 in binary is 0b101.\n",
    "Example 3:\n",
    "\n",
    "Input: 6\n",
    "Output: 1\n",
    "Explanation: \n",
    "6 in binary is 0b110.\n",
    "Example 4:\n",
    "\n",
    "Input: 8\n",
    "Output: 0\n",
    "Explanation: \n",
    "8 in binary is 0b1000.\n",
    "There aren't any consecutive pairs of 1's in the binary representation of 8, so we return 0.\"\"\"\n",
    "\"Sample solution\"\n",
    "class Solution:\n",
    "    def binaryGap(N):\n",
    "        \"\"\"\n",
    "        :type N: int\n",
    "        :rtype: int\n",
    "        \"\"\"\n",
    "        nbins = bin(N)[2:]\n",
    "        index = -1\n",
    "        res = 0\n",
    "        for i, b in enumerate(nbins):\n",
    "            if b == \"1\":\n",
    "                if index != -1:\n",
    "                    res = max(res, i - index)\n",
    "                index = i\n",
    "        return res\n",
    "Solution.binaryGap(35)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 106,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "14"
      ]
     },
     "execution_count": 106,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "\"883. Projection Area of 3D Shapes\"\n",
    "\"\"\"On a N * N grid, we place some 1 * 1 * 1 cubes that are axis-aligned with the x, y, and z axes.\n",
    "\n",
    "Each value v = grid[i][j] represents a tower of v cubes placed on top of grid cell (i, j).\n",
    "\n",
    "Now we view the projection of these cubes onto the xy, yz, and zx planes.\n",
    "\n",
    "A projection is like a shadow, that maps our 3 dimensional figure to a 2 dimensional plane. \n",
    "\n",
    "Here, we are viewing the \"shadow\" when looking at the cubes from the top, the front, and the side.\n",
    "\n",
    "Return the total area of all three projections.\n",
    " \n",
    "Example 1:\n",
    "\n",
    "Input: [[2]]\n",
    "Output: 5\n",
    "Example 2:\n",
    "\n",
    "Input: [[1,2],[3,4]]\n",
    "Output: 17\n",
    "Explanation: \n",
    "Here are the three projections (\"shadows\") of the shape made with each axis-aligned plane.\n",
    "\n",
    "Example 3:\n",
    "\n",
    "Input: [[1,0],[0,2]]\n",
    "Output: 8\n",
    "Example 4:\n",
    "\n",
    "Input: [[1,1,1],[1,0,1],[1,1,1]]\n",
    "Output: 14\n",
    "Example 5:\n",
    "\n",
    "Input: [[2,2,2],[2,1,2],[2,2,2]]\n",
    "Output: 21\"\"\"\n",
    "\n",
    "\"Sample solution\"\n",
    "\"\"\"With the example [[1,2],[3,4]]:\n",
    "The shadow from the top will be 4, since there are four non-zero values in the grid;\n",
    "The shadow from the side will be 2 + 4, since the maximum value of the first row is 2, \n",
    "and the maximum value of the second row is 4;\n",
    "The shadow from the front will be 3 + 4, since the maximum value of the first column is 3, \n",
    "and the maximum value of the second column is 4.\n",
    "从顶部看，由该形状生成的阴影将是网格中非零值的数目。\n",
    "从侧面看，由该形状生成的阴影将是网格中每一行的最大值。\n",
    "从前面看，由该形状生成的阴影将是网格中每一列的最大值。\"\"\"\n",
    "class Solution:\n",
    "    def projectionArea(grid):\n",
    "        N = len(grid)\n",
    "        ans = 0\n",
    "\n",
    "        for i in range(N):\n",
    "            best_row = 0  # max of grid[i][j]\n",
    "            best_col = 0  # max of grid[j][i]\n",
    "            for j in range(N):\n",
    "                if grid[i][j]: ans += 1  # top shadow\n",
    "                best_row = max(best_row, grid[i][j])\n",
    "                best_col = max(best_col, grid[j][i])\n",
    "\n",
    "            ans += best_row + best_col\n",
    "\n",
    "        return ans\n",
    "\n",
    "        \"\"\" Alternative solution:\n",
    "        ans = sum(map(max, grid))\n",
    "        ans += sum(map(max, zip(*grid)))\n",
    "        ans += sum(v > 0 for row in grid for v in row)\n",
    "        \"\"\"\n",
    "Solution.projectionArea([[1,1,1],[1,0,1],[1,1,1]])\n",
    "\n",
    "class Solution(object):\n",
    "    def projectionArea(grid):\n",
    "        \"\"\"\n",
    "        :type grid: List[List[int]]\n",
    "        :rtype: int\n",
    "        \"\"\"\n",
    "        res = top = 0\n",
    "        n = len(grid)\n",
    "         \n",
    "        for i in range(n):\n",
    "            side, front = max(grid[i]), 0\n",
    "            for j in range(n):\n",
    "                if grid[j][i]:\n",
    "                    top += 1                \n",
    "                    front = max(front, grid[j][i])\n",
    "            res += side + front\n",
    "        return res + top\n",
    "Solution.projectionArea([[1,1,1],[1,0,1],[1,1,1]])"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 107,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "32"
      ]
     },
     "execution_count": 107,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "\"892. Surface Area of 3D Shapes\"\n",
    "\"\"\"On a N * N grid, we place some 1 * 1 * 1 cubes.\n",
    "Each value v = grid[i][j] represents a tower of v cubes placed on top of grid cell (i, j).\n",
    "Return the total surface area of the resulting shapes.\n",
    "\n",
    "Example 1:\n",
    "\n",
    "Input: [[2]]\n",
    "Output: 10\n",
    "Example 2:\n",
    "\n",
    "Input: [[1,2],[3,4]]\n",
    "Output: 34\n",
    "Example 3:\n",
    "\n",
    "Input: [[1,0],[0,2]]\n",
    "Output: 16\n",
    "Example 4:\n",
    "\n",
    "Input: [[1,1,1],[1,0,1],[1,1,1]]\n",
    "Output: 32\n",
    "Example 5:\n",
    "\n",
    "Input: [[2,2,2],[2,1,2],[2,2,2]]\n",
    "Output: 46\"\"\"\n",
    "\"Sample solution\"\n",
    "\"\"\"实际上，要求整个图形的表面积，那么可以分解为求出每个立方体的表面积，然后减去重叠部分的面积就可以。按照这个思路，就变得简单了。\n",
    "当只有1个立方体的时候，表面积是6；\n",
    "如果有多个立方体摞在一起成为柱子的时候，表面积是grid[i][j] * 4 + 2；\n",
    "如果有多个柱子的时候，需要减去重叠面积。重叠的高度是两个柱子之间，高度最小的那个的高度。因为重叠使得两个柱子都变矮了，所以要把这个高度*2.\"\"\"\n",
    "class Solution(object):\n",
    "    def surfaceArea(grid):\n",
    "        \"\"\"\n",
    "        :type grid: List[List[int]]\n",
    "        :rtype: int\n",
    "        \"\"\"\n",
    "        area = 0\n",
    "        n = len(grid)\n",
    "        for i in range(n):\n",
    "            for j in range(n):\n",
    "                if grid[i][j]: area += grid[i][j] * 4 + 2\n",
    "                if i: area -= min(grid[i][j], grid[i-1][j]) * 2\n",
    "                if j: area -= min(grid[i][j], grid[i][j-1]) * 2\n",
    "        return area\n",
    "Solution.surfaceArea([[1,1,1],[1,0,1],[1,1,1]])"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 109,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "6"
      ]
     },
     "execution_count": 109,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "\"908. Smallest Range I\"\n",
    "\"\"\"Given an array A of integers, for each integer A[i] we may choose any x with -K <= x <= K, and add x to A[i].\n",
    "\n",
    "After this process, we have some array B.\n",
    "\n",
    "Return the smallest possible difference between the maximum value of B and the minimum value of B.\n",
    "\n",
    "Example 1:\n",
    "\n",
    "Input: A = [1], K = 0\n",
    "Output: 0\n",
    "Explanation: B = [1]\n",
    "Example 2:\n",
    "\n",
    "Input: A = [0,10], K = 2\n",
    "Output: 6\n",
    "Explanation: B = [2,8]\n",
    "Example 3:\n",
    "\n",
    "Input: A = [1,3,6], K = 3\n",
    "Output: 0\n",
    "Explanation: B = [3,3,3] or B = [4,4,4]\"\"\"\n",
    "class Solution(object):\n",
    "    def smallestRangeI(A, K):\n",
    "        \"\"\"\n",
    "        :type A: List[int]\n",
    "        :type K: int\n",
    "        :rtype: int\n",
    "        \"\"\"         \n",
    "        return max(0, max(A)-K - min(A)-K) \n",
    "Solution.smallestRangeI([0,10],2)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 112,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "[0, 5, 1, 2, 3, 4]"
      ]
     },
     "execution_count": 112,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "\"942. DI String Match\"\n",
    "\"\"\"Given a string S that only contains \"I\" (increase) or \"D\" (decrease), let N = S.length.\n",
    "\n",
    "Return any permutation A of [0, 1, ..., N] such that for all i = 0, ..., N-1:\n",
    "\n",
    "If S[i] == \"I\", then A[i] < A[i+1]\n",
    "If S[i] == \"D\", then A[i] > A[i+1]\n",
    "\n",
    "Example 1:\n",
    "\n",
    "Input: \"IDID\"\n",
    "Output: [0,4,1,3,2]\n",
    "Example 2:\n",
    "\n",
    "Input: \"III\"\n",
    "Output: [0,1,2,3]\n",
    "Example 3:\n",
    "\n",
    "Input: \"DDI\"\n",
    "Output: [3,2,0,1]\"\"\"\n",
    "\"Sample solution\"\n",
    "class Solution(object):\n",
    "    def diStringMatch(S):\n",
    "        lo, hi = 0, len(S)\n",
    "        ans = []\n",
    "        for x in S:\n",
    "            if x == 'I':\n",
    "                ans.append(lo)\n",
    "                lo += 1\n",
    "            else:\n",
    "                ans.append(hi)\n",
    "                hi -= 1\n",
    "\n",
    "        return ans + [lo]\n",
    "Solution.diStringMatch(\"IDIII\")"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 115,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "'23:41'"
      ]
     },
     "metadata": {},
     "output_type": "display_data"
    },
    {
     "data": {
      "text/plain": [
       "''"
      ]
     },
     "execution_count": 115,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "\"949. Largest Time for Given Digits\"\n",
    "\"\"\"Given an array of 4 digits, return the largest 24 hour time that can be made.\n",
    "\n",
    "The smallest 24 hour time is 00:00, and the largest is 23:59.  Starting from 00:00, \n",
    "a time is larger if more time has elapsed since midnight.\n",
    "\n",
    "Return the answer as a string of length 5.  If no valid time can be made, return an empty string.\n",
    "\n",
    "Example 1:\n",
    "\n",
    "Input: [1,2,3,4]\n",
    "Output: \"23:41\"\n",
    "Example 2:\n",
    "\n",
    "Input: [5,5,5,5]\n",
    "Output: \"\"\"\"\"\n",
    "\"Sample solution\"\n",
    "\n",
    "import itertools\n",
    "class Solution(object):\n",
    "    def largestTimeFromDigits(A):\n",
    "        \"\"\"\n",
    "        :type A: List[int]\n",
    "        :rtype: str\n",
    "        \"\"\"\n",
    "        A.sort()\n",
    "        for h in range(23, -1, -1):\n",
    "            for m in range(59, -1, -1):\n",
    "                t = [h // 10, h % 10, m // 10, m % 10]\n",
    "                ts = sorted(t)\n",
    "                if ts == A:\n",
    "                    return str(t[0]) + str(t[1]) + \":\" + str(t[2]) + str(t[3])\n",
    "        return \"\"\n",
    "\n",
    "display(Solution.largestTimeFromDigits([1,2,3,4]))\n",
    "\n",
    "\n",
    "class Solution:\n",
    "    def largestTimeFromDigits(A):\n",
    "        \n",
    "        max_time = -1\n",
    "        # enumerate all possibilities, with the permutation() func\n",
    "        for h, i, j, k in itertools.permutations(A):\n",
    "            hour = h*10 + i\n",
    "            minute = j*10 + k\n",
    "            if hour < 24 and minute < 60:\n",
    "                max_time = max(max_time, hour * 60 + minute)\n",
    "        \n",
    "        if max_time == -1:\n",
    "            return \"\"\n",
    "        else:\n",
    "            return \"{:02d}:{:02d}\".format(max_time // 60, max_time % 60)\n",
    "Solution.largestTimeFromDigits([5,5,5,5])"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 116,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "10"
      ]
     },
     "execution_count": 116,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "\"976. Largest Perimeter Triangle\"\n",
    "\"\"\"Given an array A of positive lengths, return the largest perimeter of a triangle with non-zero area, \n",
    "formed from 3 of these lengths.\n",
    "\n",
    "If it is impossible to form any triangle of non-zero area, return 0.\n",
    "\n",
    "Example 1:\n",
    "\n",
    "Input: [2,1,2]\n",
    "Output: 5\n",
    "Example 2:\n",
    "\n",
    "Input: [1,2,1]\n",
    "Output: 0\n",
    "Example 3:\n",
    "\n",
    "Input: [3,2,3,4]\n",
    "Output: 10\n",
    "Example 4:\n",
    "\n",
    "Input: [3,6,2,3]\n",
    "Output: 8\"\"\"\n",
    "\"Sample solution\"\n",
    "class Solution(object):\n",
    "    def largestPerimeter(A):\n",
    "        A.sort()\n",
    "        for i in range(len(A) - 3, -1, -1):\n",
    "            if A[i] + A[i+1] > A[i+2]:\n",
    "                return A[i] + A[i+1] + A[i+2]\n",
    "        return 0\n",
    "Solution.largestPerimeter([3,2,3,4])"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": []
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.6.8"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 2
}
